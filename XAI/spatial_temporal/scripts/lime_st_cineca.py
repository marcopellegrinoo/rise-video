# -*- coding: utf-8 -*-
"""lime_st_cineca.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P1zhD4RAKZpGmajzTtk9V6NKfQzo3AcY

### ***Cineca***
"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras import activations
from tensorflow.keras.callbacks import TensorBoard
from tensorflow.keras.models import load_model
from keras import activations
import numpy as np

"""
##### ***Data & Black-Box***

"""

# IMPORTO I DATI PER VOTTIGNASCO
import os

# Ottieni il percorso effettivo da una variabile d'ambiente
work_path = os.environ['WORK']  # Ottieni il valore della variabile d'ambiente WORK
v_test_OHE_path = os.path.join(work_path, "Water_Resources/rise-video/data/Vottignasco/Vottignasco_00425010001_test_month_OHE.npy")
v_test_image_path = os.path.join(work_path, "Water_Resources/rise-video/data/Vottignasco/Vottignasco_00425010001_test_normalized_image_sequences.npy")
v_test_target_dates_path = os.path.join(work_path, "Water_Resources/rise-video/data/Vottignasco/Vottignasco_00425010001_test_target_dates.npy")
v_test_images_dates_path = os.path.join(work_path, "Water_Resources/rise-video/data/Vottignasco/Vottignasco_00425010001_test_image_sequences_dates.npy")

# Carica l'array numpy dai file
vottignasco_test_OHE    = np.load(v_test_OHE_path)
vottignasco_test_image  = np.load(v_test_image_path)
vottignasco_test_dates  = np.load(v_test_target_dates_path)
vottignasco_test_images_dates = np.load(v_test_images_dates_path)

print(len(vottignasco_test_dates))
print(len(vottignasco_test_image))
print(len(vottignasco_test_OHE))

# """##### ***Black Boxes***"""

import os
import tensorflow as tf
from keras.models import load_model

# Se vuoi abilitare il dropout a runtime
mc_dropout = True

# Definizione della classe personalizzata doprout_custom
class doprout_custom(tf.keras.layers.SpatialDropout1D):
    def call(self, inputs, training=None):
        if mc_dropout:
            return super().call(inputs, training=True)
        else:
            return super().call(inputs, training=False)

# Percorso della directory su Cineca
base_dir = os.path.join(os.environ['WORK'], "Water_Resources/rise-video/trained_models/seq2val/Vottignasco")
lstm_suffix = 'time_dist_LSTM'

vott_lstm_models = []

def extract_index(filename):
    """Funzione per estrarre l'indice finale dal nome del file."""
    return int(filename.split('_LSTM_')[-1].split('.')[0])

# Trova tutti i file .keras nella cartella e li aggiunge alla lista
for filename in os.listdir(base_dir):
    if lstm_suffix in filename and filename.endswith(".keras"):
        vott_lstm_models.append(os.path.join(base_dir, filename))

# Ordina i modelli in base all'indice finale
vott_lstm_models = sorted(vott_lstm_models, key=lambda x: extract_index(os.path.basename(x)))

# Lista per i modelli caricati
vott_lstm_models_loaded = []

for i, model_lstm_path in enumerate(vott_lstm_models[:10]):  # Prendo i primi 10 modelli ordinati
    #print(f"Caricamento del modello LSTM {i+1}: {model_lstm_path}")

    # Carico il modello con la classe custom
    model = load_model(model_lstm_path, custom_objects={"doprout_custom": doprout_custom})

    # Aggiungo il modello alla lista
    vott_lstm_models_loaded.append(model)

print(vott_lstm_models_loaded)

"""### ***Import & Drive***"""

# !pip install tensorflow==2.15.0 # cuDNN 8.9    CUDA 12.2 # keras 2.15.0

# !pip install rioxarray==0.15.5

# import tensorflow as tf
# from tensorflow import keras
# from tensorflow.keras import layers
# from tensorflow.keras import activations
# import sys
# from tensorflow.keras.callbacks import TensorBoard
# from tensorflow.keras.models import load_model
# from keras import activations
# import numpy as np

# # Mount Google Drive
# from google.colab import drive
# drive.mount('/gdrive')
# %cd /gdrive

"""### ***Loading from Google Drive***

##### ***Data***
"""

# # Directories

# base_path = "./MyDrive/Water_Resources/"
# data_path = base_path + "data/training_validation_test_splits"
# model_path = base_path + "trained_models/"
# modules_path = base_path + "python_modules/"
# xai_path = base_path + "XAI/"
# results_path = xai_path + "results/"

# # IMPORTO I DATI PER VOTTIGNASCO

# # Percorso ai file .npy
# v_test_OHE_path    = data_path + '/Vottignasco_00425010001_test_month_OHE.npy'
# v_test_image_path  = data_path + '/Vottignasco_00425010001_test_normalized_image_sequences.npy'
# v_test_target_dates_path = data_path + '/Vottignasco_00425010001_test_target_dates.npy'

# # Carica l'array numpy dai file
# vottignasco_test_OHE    = np.load(v_test_OHE_path)
# vottignasco_test_image  = np.load(v_test_image_path)
# vottignasco_test_dates  = np.load(v_test_target_dates_path)

"""##### ***Black Boxes***"""

# from keras.models import load_model

# # If you want to load the entire model, dropout_custom layer has to be defined:

# mc_dropout = True

# # Definizione della classe personalizzata doprout_custom
# class doprout_custom(tf.keras.layers.SpatialDropout1D):
#     def call(self, inputs, training=None):
#         if mc_dropout:
#             return super().call(inputs, training=True)
#         else:
#             return super().call(inputs, training=False)

# # Trovo i path dei modelli dell'ensemble nel mio drive. Poi li ordino in base al nr del modello.
# # VOTTIGNASCO

# import os

# base_dir = base_dir = model_path + "seq2val/Vottignasco"
# lstm_suffix = 'time_dist_LSTM'

# vott_lstm_models = []
# vott_lstm_weights = []


# def extract_index(filename):
#     """Funzione per estrarre l'indice finale dal nome del file."""
#     return int(filename.split('_')[-1].split('.')[0])

# # Trova tutti i file e li aggiunge alle rispettive liste
# for root, _, files in os.walk(base_dir):
#     for filename in files:
#         full_path = os.path.join(root, filename)
#         if lstm_suffix in filename:
#             if filename.endswith(".keras"):
#               vott_lstm_models.append(full_path)
#             else:
#               vott_lstm_weights.append(full_path)

# # Ordina i modelli in base all'indice finale
# vott_lstm_models = sorted(vott_lstm_models, key=lambda x: extract_index(os.path.basename(x)))
# vott_lstm_weights = sorted(vott_lstm_weights, key=lambda x: extract_index(os.path.basename(x)))

# # Lista dei path dei modelli e dei pesi
# vott_lstm_models_loaded = []
# racc_lstm_models_loaded = []

# for i in range(10):
#     print(f"Caricamento dei modelli LSTM {i+1}")

#     # VOTTIGNASCO
#     model_lstm_path = vott_lstm_models[i]
#     # Carico il modello CNN+LSTM
#     model = load_model(model_lstm_path, custom_objects={"doprout_custom": doprout_custom})
#     # Aggiungo il modello alla lista
#     vott_lstm_models_loaded.append(model)

# vott_lstm_models_loaded

"""### ***ST-LIME***

#### ***Spatial-Temporal Superpixels***

###### ***Temporal***
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
#import imageio
#from IPython.display import Image

def get_season(day):
  spring = np.arange(80, 172)
  summer = np.arange(172, 264)
  fall = np.arange(264, 355)

  if day in spring:
    season = 'Spring'
  elif day in summer:
    season = 'Summer'
  elif day in fall:
    season = 'Autumn'
  else:
    season = 'Winter'

  return season

# Mappa le stagioni ai colori
season_colors = {
    'Winter': 'blue',
    'Spring': 'green',
    'Summer': 'yellow',
    'Autumn': 'orange'
}

# # Esempio

# nr_instance = 0

# vottignasco_test_images_dates = np.load(data_path + '/Vottignasco_00425010001_test_image_sequences_dates.npy')

# # Converti le date in pandas datetime
# dates = pd.to_datetime(vottignasco_test_images_dates[nr_instance])

# # Estrai i giorni e identifica le stagioni
# tm_days = [date.timetuple().tm_yday for date in dates]
# seasons = [get_season(tm_yday) for tm_yday in tm_days]

def cluster_seasons(seasons):
    clusters = []
    start_index = 0

    for i in range(1, len(seasons)):
        if seasons[i] != seasons[i - 1]:  # Cambia stagione
            clusters.append((start_index, i - 1, seasons[start_index]))  # Salva il cluster precedente
            start_index = i  # Inizia un nuovo cluster

    # Aggiunge l'ultimo cluster
    clusters.append((start_index, len(seasons) - 1, seasons[start_index]))

    return clusters

# temporal_superpixels = cluster_seasons(seasons)

# for start, end, season in temporal_superpixels:
#     print(f"Cluster {season}: from index {start} to {end}")

"""###### ***Spatial***

------------------- Exctrated (lon,lat,dtm) ---------------------------

![Screenshot 2025-02-08 104909.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArUAAAG/CAYAAABG0y+6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAP+lSURBVHhe7N17VFN3vjf+dwkEE8LFEK5JkAiFcAuglQC1YijYjh2D4rTOyPTCjHPpFJfLM2edZ60z7dSO8/ScOWs9y+Uj9j7TnrZ2xukMKrX9TYWK9KKilnIRuVSFmnA13MIlkgDz++Owv0+ySUJQrGA/r7WyWvf3u7/7Cnz2Z3/2zj2ZmZn/BCGEEEIIIUuYF38CIYQQQgghSw0FtYQQQgghZMmjoJYQQgghhCx5FNQSQgghhJAlj4JaQgghhBCy5FFQSwghhBBCljwKagkhhBBCyJJ3z1J+T61Wq8WqVasgEAgcpg8MDOC9995zmEYIIYQQQu5eAoVCsYc/calQKBQIDQ1FbW0tjhw5gnPnzmF4eBhxcXGIj49HY2Mjf5ZZCgoKkJWVBZPJBLPZzG9eENu3b0dKSopH60MIIYQQQubvris/aG1tRX19PSQSCbRaLb+ZEEIIIYTchdyWH3C397u6unDs2DEoFArk5eUBACorKyGXyx1u/9vf9t++fTsEAgEkEgksFgvGxsYQEBAAABAKhaitrUVnZyfy8vIgkUgAAFarFdXV1QgKCkJycjI+//xztLa2suVeu3YNJ0+edFi/1NRU1NfXo6amhk2Pj49HTk4OLl++jJMnT7L5+cuRy+VITEwEAIyOjs65Tfxyh0uXLrH14ZYpFAod2goKCqBUKmeNRQghhBBCFo7b8oPOzk4IBALExMTA29sbcXFxEIlEqKysBGaCvKtXr+Lw4cO45557EBUVBW9vb3R2diIlJQV+fn44deoUPvnkE4SHhyMyMhJff/013n//fXR2dkKn00EgEOCPf/wjurq6sGLFCkgkErS2tkKlUuGf//wn2tvbkZCQgPDwcDQ1NaG/v5+tn0KhQHh4OHp7e9HZ2cmmi0QirFixAtPT02htbXW5nH/84x+IiIiAQCCYc5vuueeeWW3x8fEYHx+HSCRCTk4OTCYT3nnnHdxzzz1ITEyEt7c3PvnkE8TGxsJisVBASwghhBBym8xZflBTU4Pe3l6sWbMGkZGRaG5uhtFohNFoxFtvvcUylX5+frMe2BodHUVrayv7t9VqdQg+jx07xgI9Pz8/luU0Go0YHBxEeHg4ACA8PBwWi8VhrPlwtRw+T7YpKioKCoUCNTU1+OMf/4jW1lbI5XIIBAK0tLQAM/tsdHSUrT8hhBBCCLm95gxqAaClpQVWqxVdXV0Ot/m3b9+OkpISlJSUIDY2FlNTUw7zzSU3N5fNn5ub69DW09MDkUiE+Ph4+Pn5oaenx6HdHS5wHRkZAeZYDp+rbTIajSybu3nzZpSUlOCpp56CQqGAn58fRCIR8vPz2bxSqRR+fn680QkhhBBCyO3gUVC7evVqCIVCREZGsoevtFotJBIJzp8/j9LSUtTX1/Nnc0uhUCAqKgoGgwGlpaX44IMPYLVaWXtnZyempqYQGxsLoVDokOGdC5c5HRsbm3M59ubaJi6TW1paioqKCgiFQqxevRpjY2OwWCyoqKhAaWkp+1C5ASGEEELIt2POoDY3NxcSiQQVFRXo6upCQkICFAoFAEAgELBsZExMzKxb9Z7g5o+Li2MPcsGuBEGlUgEAxsbGWJs78fHxiI2NxfDwsENW2dVy+FxtU3x8PH7+85+zTO/Y2BisVitGRkZYAK5Wqx36FhQU2I1MCCGEEEJuF7cPiuXm5iIxMRGtra24cOECxsbGsHLlSigUCvzjH/9AXFwcoqKikJGRgZ6eHkgkEoyOjqK9vR0pKSkAwN7NqlKpIJVK8c0336C/vx9msxlSqZTNLxAIYLFYIBQK2TxBQUEIDw/H9evXcf78eSgUChQWFkIqlaK9vR0KhQJyuRwKhQIZGRnIyMhATEwMurq68Le//Q0A5lxOUFAQoqKiEBsbi9bWVoe+9tt04cIFeHt7IyUlBZmZmVCr1RgdHUV5eTnMZjMsFguSkpKQlZWFmJgYDA8Ps3UICQlBVFQUEhMTb+v7cAkhhBBCvqvcvtLrTouPj8fatWtx8eJFh6wrIYQQQggh9uYsP7iT5HI5pqam5lVPSwghhBBCvnsWbVC7fft2xMfHs1eIEUIIIYQQ4sqiLj8ghBBCCCHEE4s2U0sIIYQQQoinKKglhBBCCCFLHgW1hBBCCCFkyaOglhBCCCGELHkU1BJCCCGEkCWPglpCCCGEELLkuXylV3d3N38SIYQQQgghLkVERPAnfWtcBrWEEEIIIYQsFVR+QAghhBBCljwKagkhhBBCyJJHQS0hhBBCCFnyKKglhBBCCCFLHgW1hBBCCCFkyaOglhBCCCGELHkU1BJCCCGEkCWPglpCCCGEELLkUVBLCCGEEEKWPApqCSGEEELIkrfgX5Or1WqxatUqCAQCh+kDAwN47733AAAKhQJ5eXkYHBzEsWPHHPp92xbTutwNkpOT8ctf/hKfffYZDh8+7NC2bt067NixAxaLBQcOHMDFixcd2r8N27Ztw0MPPYS33noLn376KTCzzjt37oRUKgUANDY24ne/+x1vzv+Z95FHHsGHH344a9tc2bdvH8LDw3H06FGP5/HUb3/7W6SkpLB/WywWvPHGG2y73OHmPXnyJF5++WV+84KzX9eBgQF2/J9++mnExcVh9+7d/FkIIYSQebktmdqpqSmcP38epaWlKC0tRUVFBSQSCbZv387vSu4yhYWF6OvrYwHctm3b8Ic//IHf7Y7Ytm0bNm/eDG9vb4fpP/3pTwEAL7zwAl544QXI5XI8/fTTDn2Sk5ORm5sLHx8fh+kL7Q9/+AO2bdvGn+zU8uXL0djYiEcffRSPPvoonnjiCY8C2m/b008/jdjYWBw4cAAvvPACYLfPuYCav78JIYSQ+botQS1fa2sr6uvrIZFIoNVqYTQa8dZbby2KzOhiWpelbt26dZDL5Th16hRgF0QKhUIAwKeffoonnngCv/jFL771LO1vf/tb/OAHP0BPT4/D9HXr1iE4OBh1dXW4ePEiLl68iLq6OsTFxTn0e+CBByASiWCz2RymL6R9+/YhKiqKP9mp5ORkiMViXL9+nd+06ISEhMBisWBgYAAXL15EZ2cnxGIxkpOTAQBnz55FUlIS+zchhBByM+YsP/Dx8YG/vz8GBwfxz3+67QrMlB+kpqaivr4eNTU1bHp8fDxycnJw+fJltLW1sVv+X375JfLy8mCxWBAYGAihUIjR0VFcuXIFycnJEAgEGB0dRWVlJYxGIxuHC5QuXbqEkydPsjKCqakpSCQSCAQCWK1WVFdXo7W1lbVLJBLArhzCWfnB9u3b2a1o+7KJ7du3QygUss/U1BRqa2tRU1PjcnwAKCgogJ+fH/v33cr+VjJXaiASiYCZW+Off/451q5dy8oPCgsLkZKSgtbWVsTExMDb2xsWiwVNTU247777AN6tan6ZgNFoZLet161bh6eeegoff/yx09v8xcXFOH/+PB544AFkZWWx2/Tcep45c8Yha5iWlsaWu27dOhQVFaGurg5ZWVm3VH7ALxngSh2cTb9+/brDethztt7zwS8/4B8v+/1uXzZis9kQFhYGAA6lC7/97W+xfPlyp2UETz/9NNvnAwMD2LlzJzo7O1mJx1zHjhBCCPGEQKFQ7OFPtCcQCODv7w9/f3/4+vrixo0b/C4OFAoFwsPD0dvbi87OTjZdJBJhxYoVmJ6eRnd3N1auXIkbN26w//fz80N1dTWuXr2KmJgYBAYG4h//+AdGRkZY9spmsyEnJwcmkwnvvPMO7rnnHiQmJsLb2xsjIyNYuXIlli1bhlOnTqGxsRErVqxAWFgYGhsbodPpIBAI8Mc//hFdXV249957IZVK0d/fz9altbUVBQUFkEgk+Oijj2AwGBAXFweFQoHW1lakpKRAIpGgrq4OR44cQVxcHMLDw2EymbB69Wqn47e3t6O1tRWNjY12e+nuVFRUhMHBQVRXV+Obb76BUChEXFwcurq68Mtf/hJ+fn5YtWoVJicnce7cOSQkJCAsLAw3btzAz372MyQkJEAul2PZsmX4r//6LwQHByM6OhrBwcHo7+/Hzp07IRKJ8Morr8BgMOC+++5DUlISW96xY8fQ1NTEXy0AQF1dHfr6+rBmzRoolUrU1tbim2++gb+/P1atWoXw8HB0dHQgNDQUBQUFEIlEaG5uxjfffIMnn3wSIyMjMBqNiIuLw9dff+1yOXwPP/wwJBIJWlpasG7dOmRmZuLkyZP4t3/7N2RnZ0OlUsHb2xsvvfQSsrOzIRaLUVZWhpdeegkXLlzA8ePH0dfXxx8WmZmZSEpKQkxMDB577DE89thjkMlkuHDhAr+rUzk5OQgLC0N7ezvEYjELWv/rv/4L1dXV0Gq1WL9+Pfr7+wEAq1atglgsxokTJ/DJJ59Ao9FAJpOho6MDfX19qK6uxscff8xfDADgwoULEAqFePzxx5Gbm4szZ87g//yf/8Pav/nmG6xfv579DiCEEEJuxrzKD4RCIcLDwxEcHIx77rmH33xLent70drairGxMVitVgwODsJoNGJoaAhTU1MAALlcDoFAgJaWFgBATU0NRkdHER4ePmsco9EIq9XKpgNAYGCgQ/nDyZMnHdoVCgWWL1/Olt3a2ore3l4sX74cCoUCADA8PMwy0GNjYw7zzzX+3exWbocPDg4CAJu3s7MTFy9edBgrKSkJAQEB6O/vx6effoqmpiaYzWbI5fJbum198eJFHDp0CCKRCM8//zx+85vfOCx327ZtCA0NRVlZmcN8N+Pll1/Go48+ipCQELz//vvsnLoZXLb6b3/7Gx599FGcPHkS69at87ge115SUhJEItGsEgyRSISkpCTWz2w2o6mpCQMDA7BYLBCJRGw93Pntb3+LRx55hG1/XFwc9u3bx++G5cuX8ycRQgghHptXUMu5meDWz88PQqEQIyMj/CaP+fn5QSQSIT8/HyUlJSgpKYFUKoWfnx+/6yzHjh1DV1cX1qxZg5KSEjz99NPQarUOfW5lHT0Znzg3n0BYoVDg/fffx/PPPw+pVOpxYOUOV+v76KOP4kc/+hGsViurAc3MzERTU9Os2/834+mnn8b777/PHpoyGo38Lh57+eWX8aMf/Yjdrv/ss89gNpsRHx/P7zqnkJAQ/iTGXZsnkpOTIZfLcfnyZfYQ29mzZxEcHOwQgHMXNoQQQsjNuqmg9p///CdMJhP6+/s9qrOFXZaVn92cj7GxMVgsFlRUVLA3K5SWlnpcq3rs2DE2z/DwMBISEhyyvFyW2N/f32E+Tzkb/1aycWQ2o9HInva/XU/8L1++HOPj45BKpQgODkZubi7ef/99/OAHP4BIJMIPfvCDm3paPy4uDpOTk/jwww8XfJ0587lA4Libx13bQqIsLSGEkFs1r6CWC2Z7enrm9RR4fHw8YmNjHW7d34zOzk5MTU1BrVYDM+P+/Oc/R0FBAb/rLNu3b3d4pRgXwNo/DW80GjE4OMjKDeLj4xEWFsbKEdxxNf5c890tLl68iPHxcYfMXnd397zOE3e4coPg4GB2m/3Pf/6z09vY87Vv3z789re/BWayqeHh4Th79qxDBvfRRx/F3/72N1gsFvztb3+7qYezAMDb2xtSqRTbtm1zuKDCPLOVv/3tb/Hqq6+y0ovCwkKIRCKPa33tNTU1wWKxIC0tDcnJyUhOTkZaWhp7aO9WcG87iI2Nxbp164CZemBnY89n+wkhhBA+j4La6enpeQWzAoGA3YYvKSlBfn4+ent7Pc6oumI0GnHmzBmEhYWxcUdHRz16Hdenn34KoVDI1iksLAxffvklvxuOHTsGq9WKzZs3L9j4BQUF34l39La1tTlk3D799FP09/dDoVDgz3/+MzIzMx36z8fFixdx4MABWCwW7Ny5Ez/4wQ9gNpvxxz/+EZh5gv5Pf/rTTdWUHjlyBLGxsXj//feRm5uLTz/91KOn8Oe7zCNHjsBisSA3N5e9XowLcjHz6jsA+MEPfoB9+/bh6aefdghc7f3ud79DZ2cnnn/+ebz//vtISEhgGeDk5GS8+uqrHmeTP/30U7zxxhusrvj5558HAPzXf/2Xxxnl3/72ty4vMH73u9+xB/3ef/99iMVihzc6rFu3DoGBgWz7CSGEkJsx5yu9CPEU9+qrQ4cOeRwMLXX/63/9L3R0dHgUBH+buID2ZjPK3yb+K9QIIYSQm+FRppYQT3z66afo7OzE+vXr+U13peTkZPj7+8+6jb4YREZGLsr1ciYuLo69eYEQQgi5WZSpJQsqOTkZv/zlL/HZZ58tuuwlWXzsv7CDEEIIuRUU1BJCCCGEkCWPyg8IIYQQQsiSR0EtIYQQQghZ8iioJYQQQgghSx4FtYQQQgghZMmjoJYQQgghhCx5FNQSQgghhJAlj4JaQgghhBCy5FFQSwghhBBCljwKagkhhBBCyJJHQS0hhBBCCFnybtvX5Gq1WqxatQoCgQAAMDo6isrKShiNRn7XBVdQUIDly5ejsrIS69atAwC89957/G6EEEIIIeQucVsytbm5uVizZg1aW1tRWlqK0tJSWK1W5OXlQaFQ8LsvevHx8fj5z3+O3NxcfhMhhBBCCFkEFjyoVSgUiIqKgsFgwMmTJ9n0L7/8EkKhEHFxcQ79b7f33nuPsrSEEEIIIXe5OcsPFAoF8vLyIJFI+E1OSwq0Wi1SU1NRX1+Pmpoah/5827dvh1QqBQAMDAw4BJ8FBQVQKpUAbzm5ublQqVQAAKFQiNraWnR2drJ1nJqawujoKAQCwazyg+3bt0MoFLLP1NQUamtr2Xrm5uYiMTGRrYPBYMCXX37psP2XLl3CyZMnHcor+OPYbxd/3aOiombtM0IIIYQQcmvmzNQajUZcu3aNPxkAcO3atVnBmZ+fHwBgaGjIYTpfQUEBhEIhjh49ioqKCkgkEhQUFAAzwWVYWBgqKipw9OhRAGDBKQCIRCK0t7fj5ZdfRk1NDVavXg0AOHr0KE6ePAmRSMT68olEItTX16O0tBTDw8NISEiAQqFAfHw8VCoVzp8/j9LSUly6dAlhYWHw8/PDmTNnYLVaWUAbHx+P1NRUVl7R2tqK1NRUxMfHIzc3l20XV3bBrd/Jkyfx1ltvzdpnhBBCCCHk1swZ1AJAW1sbRkdHHaaNjo6ira3NYZqnFAoFli9fjsHBQRiNRrS2tqK3txfLly+HQqFAeHg4RkdH0drayoJqiUSC+Ph4AIDVakVnZ6fbsVwZHh5mGdWxsTE2vbW1FX/84x9Zm7+/P2vjk8vlsFqtbPvb2tpgtVohl8sBABKJhJVZvPfeezh27JjD/IQQQgghZGF5FNQ6y9Y6y9LCLlAMCgriNzF+fn4QCoUYGRnhNyE8PBxCodAh4HTH2VjOxp2LQqHAU089hZKSEpSUlCAkJITfhfH394dEIsHmzZtRUlKCzZs3QyKRwN/fHydPnsSlS5eQmJjIxqIHzAghhBBCbi+PglrwsrXusrSdnZ2wWq0IDw93mM4FjQUFBRgbG4PVanWaDe3p6YHVamVlDHNxNpazcecSFxcHoVCIiooKlJaW4urVq/wuzMjICEZHR1mJAffhMrInT55k0wwGA2JjY1mWmRBCCCGELDyPg1r7bK2rLC3s+imVSocM5erVqyEUCtHS0gKj0YjBwUFWbhAfH4+wsDBWQtDT08PKDbi3KXDlCHzcWGFhYaz/8uXL+d08IhAIEBQUxJbpSmdnp8ObHLRaLZ5++mnk5uaioKAATz31FHt12cjICKxWq8eZZ0IIIYQQMn8ChUKxhz/RFZvNhsDAQDQ0NMBsNvObmfb2dtxzzz1ISUlBZmYmMjIyIBAI8PHHH6O9vR2YqWFNTExEeno6YmJiMDw8jL/97W9sfoVCgfT0dKjValitVlRVVcFsNkOlUkEqleKbb75Bf38/Gys+Ph7JyclQq9Xs7QdXr17FihUrAACNjY1ISUlh/w8AarUaIpEIV69eRX9/P6KioqBSqXDvvfeiu7sbAQEBGB4eRn19PeLj4xEVFYWIiAh88cUX8Pb2Ztsnl8vR2dmJf/zjHw7blZGRAalUisbGRjQ3NyM3Nxc5OTkwmUxu9x8hhBBCCJmfOV/pRQghhBBCyGLncfkBIYQQQgghixUFtYQQQgghZMmjoJYQQgghhCx5FNQSQgghhJAlj4JaQgghhBCy5FFQSwghhBBCljwKagkhhBBCyJLn8j21ExMT/EmEEEIIIYS45Ovry5/0raFMLSGEEEIIWfLuWKb24MGDiIiIwN///nccOnSI30yWKI1Gg5KSElRXV0MqlWLt2rV45ZVXUFVVxe/qEfvx6DxZ2goLC6FUKmGz2SAWi9Hb24t33nmH3+2WJCQkQKfTwcfHBwDQ1NSEyspKfjc8/vjjADDv5aelpSEqKgoAMDk5icbGRhgMBn43AIBOp4O/vz8AYGRkxOFnIDs7GzKZDHAxjrt5OfbrYs9Vf6VSiZSUFHh7eztdpv063bhxA7W1tTCZTJDJZFi1ahWWLVsGuBmf348zPT2Ny5cvo6WlxWG6PZ1Oh4mJCZw+fZpNU6vViI2NhZeX16wx7LcFAK5du4a6ujo27626mW1xd2642xZ8C8cbLvYRt519fX0ObXOdn4S4cycztQKFQrGHPxEApqam+JMW1COPPAJ/f380NzejsbGR30yWqJKSEoyNjWH//v3QarWIiorChQsX0NHRwe/qkd7eXgQEBCAnJwfffPMNent7+V3IEpCQkICUlBS0tLTg8OHDiImJAQA0NDTwu3osISEBjz32GAIDA3H16lUolUrodDqMj4/jtddeg5eXF5KTk+Ht7Q2j0cjmy8vLw4oVK2CxWOa1fLVajejoaBgMBlRXVyMkJARyuRzDw8MYHx936JudnQ1/f3/U19fj/PnzUKlUiIyMhMFgQFpaGkJCQlibQqFAWFgYGyc7OxsikQjnzp2DyWSCXC5HSEjIrKCip6cHra2t7HPPPfcgMDAQBoMBJpPJoS8ArF69GpOTk/j444+hUCgglUrZz2VaWhrCwsLw9ddf44svvkBUVBTCwsLQ0dEBrVaL6elpfPzxxxgfH3e5PuPj47hy5YrDOkVGRsJms+HChQsOfe1xAd34+DgbU6lUQq1Wo7OzE9XV1ZDJZIiIiMCNGzcgFAqh0WhgNptRWVkJkUgEhUIBLy8vp9t9M+a7Le7OjeDgYJfbYjabb8vxlslkc+4j+8B9eHgYPT09wMy54O78JItLZmYmtFotEhMTZ32USiWuX7/ucZLSy8sLcrkcK1euRFxcHJKTk5GUlISYmBjI5XJIpVIIhULcuHHDbYzIXUjdCVR+QBaMTqeDQqHAyZMn+U235NChQ7DZbMjJyeE3kSVkamoKY2Nj/MkLRqFQQCAQsKDjzJkzeOmll3DmzBnWR6lUsmzxfEmlUoyNjbGM1unTp3HixAmnAYVEIsHQ0BALTLq7uyEWiyGTyVBXV4ePPvqItQ0ODsLb2xsikQiYyXLYbDaYTCYYDAZYLJY5Mx8ymQxRUVEYGhpymkVUKpUQiUQYHBwEZtbH19cXSqUSALB8+XIMDAyweauqqlj2z/7/PV0fzARHIpEIly9f5jcBM+u0ceNG+Pr6wmq1OrT5+fkBMxljABgYGGDTRSIRvL29WYDV39+P6enpWVnVhTTXtrg7N9xtC27T8Z5rH6nVamRmZgIzmVh7c52fZPEICAiAXC5HRUWF04+/vz/y8/OhUCj4s86iVquxY8cObN26FTk5OUhPT0dsbCxWrFiB2NhYpKam4oEHHsDmzZuxY8cOpKWl8YdYFBZNUFtUVISysjKUl5ejvLwcBw8enNX22muv4c0330R5eTnKyspQVFTkMAa5s5KTkzE+Pu70VhgA7N27lx3fN998ExqNBpg5vocPH8Zrr73m9Phj5g+BWq12mEaWBq4kYNmyZcjIyEBhYSG/CwoLC7Fr1y7s2rULO3bsYMEWZjKrXNuuXbtYGcP9998PHx8fJCUlIS8vDxEREZiamsLo6KjD2PbWrFmD4eFhjIyM8JvmJJFIPM54OOMqMFi+fDksFgsLIiYmJuDj4wOZTDYrGHVFoVDA29t7VnaPww+sMJOV8fPzY8vwJAvn6frIZDKEhoY6BPbOXL16FRcuXMD09LTDdO7ihwvCpFIpJicnYTKZYLFYMDk5CbFYDAAIDg4GZgK322GubeEuYlydG+62BbfpeM+1j2w2G5qbm9Hc3OwwnzP885MsLiMjIzCbzU4/AFBRUQGtVjtnYPvQQw85/f3kjLe396JNMi2KoLaoqAhbt25Fd3c39Ho99u3bB5lM5hD4AEBgYCDefvttHD58GJi5xUcWD7VazbIQfDt37kRcXBz27duHZ599FgDwi1/8grX7+PjAZrNBr9fj8OHDiIiIwM6dO1l7S0sLAgMDodPp2DSyNDQ3N6Oqqgo2mw1NTU0oKytzaM/Ly0N4eDhOnDjB2tavXw/MBMQxMTE4d+4c9u/fj6amJoSHh0MikeCLL75gY3J1sxMTE1i/fj0LgPPy8thyEhISIJVKPfpD7srU1BQ2btwIvV6PjRs3OgTfHJPJBJvNhqCgINYeEREBb29vFlxiJvun1+vh5+eH7u5uNv306dPo6+tDdnY2UlNTcfXq1Vm1kPbmCro409PTLMAaGxtzCCSnp6fh6+uL73//+9Dr9diwYQOrqeTodDqkp6djcnLSoZzDmbmCLsxkfZ1lGTHTdu7cOYSGhkKv18PX15dlPk0mE06cOAFfX1/o9XqEhobi3Llzbpd1KzzZFrg5N9xtC27T8Z5rH125cgVXrlzhz+bA1flJlpbExESMjIwgPz+f33RXWhRBLZeB4x4SqKqqQltbGwIDA5GSksL6mUwmVFVVoauriz1sYh/0kjtHo9FALBajr6+P3wTMHGPu+DU0NKC2thYymYwFqTabjR1/7vjy+fj4IDIykj+ZLHEREREYGRlBc3MzDAYDOjo64O/vj4SEBDQ3N+PVV19lJQQBAQH82R1IpVJ0d3ezADghIQFZWVkAgPvuuw8dHR23FNQGBwejsbER5eXlsFgsSEhImBX8AUBjYyMmJyeRnp4OvV4Pm802KxtZV1eH8vJyGI1GxMbGst+DOp0OoaGhOH36NM6ePYuoqCi3F/AymQze3t4uLyg94eXlhcDAQJw9e5b9HNr/7sXM7+Xy8nLYbDasWrXK6XZzbjW7x90e7+vrQ3l5OQYHB1mgyJUtTExMoLy8HNeuXUNGRsZtu5Pj6ba4OjfcbQtu0/FeiH3k6vwkS0dNTQ3MZjOMRiM6OzvdZmvn83wBAJelOHfaoghqpVIpfxIwk+J21UaWDqVSCbFY7PaX8FxcBbpkaVMqlfD19XVZa6tUKrFjxw6WeQ0JCeF3cTA2NobW1lYAQGtrKywWCyIiIpCVlQVvb2/WdrP4dbLe3t5OgzsuU8aV03AlEc6202g0wmq1QiqVstvPfX19LCvZ19fnkPXlW7ZsmcPtbFe4cgPMlCN4eTn++ucvUyQSOV2mu+3GTNDl4+Mz5y10d6RSKaxWK8sIG41GTE5OQqlUslvp3HFoaWlhx3mhzWdbXJ0b7rbldh3vhdxH9ucnWVqMRiMuXbqES5cusXIEV77++mscOXIEtbW16Ovrw8TEBLsQn56ehtVqRX9/PxobG3H8+HF89tln/CEWhUUR1LoKdiYnJ122kaXDYDBgfHz8ln4pRkZGstc0kbuHwWDAxMSEw215e/Hx8RAKhThx4gT279/v9papq1/aZrMZERERCAgIYLW7UqkUUql0Vv2uO84uquxv6bsjFosxOTkJi8XCb5r1UM98LV++nD1o5Aq/3AB2687VX/K5Wl+uNtTVdnOZRPv63aXKk20xzZSb8Hl6bsyXJ8d7Id3q+Um+HUFBQVi+fLnTjyfy8/MRGRmJ9vZ2/PnPf8Yrr7yCAwcOoLS0FAcOHMDLL7+Md999FxcuXEBISAiKi4v5QywKiyKo5eqquFsuOp0OcXFxGB4eptd9LRENDQ0YHx9HaGgovwmYOcZcuYFGo8GqVatYOYKnbDYburq6+JPJEtfd3c3KDZRKJaKjo1k5AgAIBAKWuYqOjubPznR2dkIoFCI+Ph6wC4g7OztRVlaG/fv3s8/AwAAGBgbwxhtvzHlbmTM4ODirTnZiYsLp/NnZ2ay0Rq1WQyqVsmxcWlqaw+1n7r/9/f0wzDz9HhoaCplMxuonXd3+9jSTyF08cJk6+3U3mUwYHR2dtczR0VGYTCbodDq2LXOtDzzMJM5lYGAAQqGQ3S5VKBQQCoUYGBhgDztx+02tVsPPz2/OfXAzPN0Wd+eGu225Xcf7VvaRu/OTLF4ajQZbtmxBVlYW+zz66KPIyMjgd3UqICAAWq0WW7duRXFxMfts3ryZTdu1axeKi4uh1Wr5sy8aiyKoPXToEP7+978jIiIC5eXl2L17N0wmE4qLi+dd50HunJaWFpfZ2AMHDqCtrQ27d+/G73//ewDAq6++yu/mklqtxvDw8LyCYLI0VFZWoqenBxs2bGBvRjh16hRgV0KQkZGBzZs3s5rtoKAgNDc3Y2RkBElJSSgsLGQPpMXFxWHXrl1ISEjAV199dUs1tPbq6urQ1dXF6mR9fHzYRbdMJsOGDRvYa27a2trg4+MDvV6PuLg4DAwMsId/6urqMDQ0xMaRSqW4evUqC2K4MbOzs5GdnQ2bzebyvOeyaM6kpaU5PPB1+fJliEQi6PX6Wa+nOn36NEZHRx2WydXWNjY2sm3hEg/ukg3cE/d8SqUSDz/8sEe1mS0tLTAajYiKioJer4dCoWBfWGAwGHD16lVIpVK2f41Go9OHq/jHhb8O9hcfzrjaFv647s4Nd9uC23S857OP+OY6P8nixCUCBgcH2aexsRFDQ0P8rk5VVFSwu10BAQHso1AooFAoHJ5nMJvNqKiosJt78bhj3yhG7j46nQ5PPPEE3n77bZe/lG+GRqPB7t27UVtbiwMHDvCbCSGEkO+cgIAAZGZm4sSJE1AqlS5L9K5evYrMzEwYjUaXby7JzMzEpUuXHIJZAPD392evQOQeOjMajVAoFC7Hmus9y7fTHftGMXL36ejowH333QeVSrWgQW1eXh6USiXef/99+kYxQgghZCZ4VCgUuHLlCtavXw+tVov4+HhERkYiJSUF8fHx7K0cCoXC4f21fFu3bkVMTAyWLVvGgtcrV67g6tWrLJCdmJiAQqFAfn4+0tPTUVNTwx8GuMPfKEaZWrKgNBoNSkpKUF1djUOHDvGb522hxyOEEELuBvaZ2rnMlaktLi6e85WJfPv37+dPAu5wppaCWkIIIYSQJSYgIABbt251mTG1l5CQ4FA3yxcQEIDExMQ5HwIzm83o7OzE2bNnXY5FQS0hhBBCCJkX+/pXd7iSAk/YPyjG4QJYT8agoJYQQgghhCx5dzKoXRSv9CKEEEIIIeRWUFBLCCGEEEKWPJflB7f6HemEEEIIIeS7hftWxzuBMrWEEEIIIWTJc/nlC7f7e56PHDmCf/u3f4OPjw/Onz/PbyZLVEZGBl5//XUEBQXhkUcewX/8x3+gr68PbW1t/K4uHTlyBAkJCeyrUsnd4cknn0RhYSGys7Px8MMPIzExEefOneN3uyWpqan46U9/iry8POh0OgQGBjq961RSUoKMjIybXr5Go0FOTg4EAoHTLwT5/ve/j7i4OJfn/YMPPojs7GxoNBokJCRgfHx81tdZhoWFYcOGDQgMDERnZ6dDmzPuljnX+trTarW4//77na7TfMZx15fbNrlcjvb2doc2jv0+4u8nbv7Vq1dDo9EgNDTU5Tj23O0jd9vNsV+n2NhYDA4OYmxsDJgZe82aNdBoNFixYoXTZfDd6j7SaDTQ6XRITU1FUlISvLy8Zo2j0Wiwdu1a3Lhxw+V2EbKQuK/mvhOWRKZ206ZNOHLkCDIyMvhNZJH52c9+hs7OThw8eJDf5NKmTZtw5swZ7NnzP9dXf/rTn7B27Vps2rSJ35UsUampqZDL5aitrcWLL76I7u5ufpd5S01Nxb//+7+joKAAAKBSqZCXlwez2Yznn38e1dXVSEpKQm5ursN8BQUFCAkJcZg2H2FhYYiJiYGXl/Nfn1qtFoGBgfzJjFarRXBwME6fPo1Dhw5hfHwcaWlpCAsLY33CwsKQnZ0NsVjsMK8r7pY51/raU6lUWLFiBX8yMM9x5uqbnJw857aJRCL09PTg0KFDOHToEP7617+y4G7NmjUAgMrKSpw+fRrBwcFzvl/T3T5yt90crVaLkJAQNDY24tChQ7DZbGw9HnzwQYjFYnZMuWnu3Oo+UqlUUKvVaG9vx6FDh3D9+nWo1WqoVCrWR6PRIDExEQKBwGFecvfQ6XR46qmnnH42b96MoKAg/iwuCQQCqFQqaLVaPPzww9i2bRt+/OMfY9u2bdi4cSOys7MRGxuLZcuW8WddNJz/NC0imzZtwr//+7/D39+f30QWmU2bNkGlUqG8vJzfNC8ffPAB2tvbodfr+U1kCZuammLfIX47qFQqeHt747PPPgMAnDx5Ei+++CJOnjzp0EelUt3SKwujo6Ph4+OD6elpfhPCwsIQFhYGm83Gb2JqamocArTr16/Dx8eHBTBc9g2A23E4cy3T3fryrVy50mW/+Yzjrq9KpUJQUJDL9cXMNvn4+GB0dJTfBJVKBV9fX1y5cgW9vb1ob2/HX//6V7cvoJ9rH7nbbk5ISAiuX7+OhoYGAMDx48dx/PhxhIWFISAgAP39/eyYXrt2DX5+fg4XKny3uo+4v4kWiwWYOY/spz/44INISUlxug/J3SEoKAgrVqzA0aNHnX6CgoKwefNmREdH82edRaPR4Ne//jWeeuopbNy4EVlZWUhMTMS9997LvpThoYcewuOPP45//dd/nfMi8k5ZNEHt66+/joaGBvZ5/fXXkZGRgV27dsHPzw+hoaF4+eWX8cwzz/BnJYvE6tWrMTIygg8++IDfBMyUFXDH98svv8QzzzzjcIwLCwtZtrazsxMqlYqy83eB1NRUPPLIIxCLxcjJycGTTz7J74Inn3wSL7zwAl544QX8+te/dsg2FRQUsLYXXngBTz75JMvK+vr6YtWqVSgoKIBSqcTk5KTLb7kBgHXr1mFwcNBtH3dUKhUiIyPxzTff8JuAmeza2NgYxsfH+U0uhYSEYHx8nAVEVqsVdXV1qKur43d1yt0y51pfexqNBn5+fk6z6PMZZ66+SUlJ6OnpcRuwicVi+Pj48CcDAEJDQyEQCOZ1geRuH7nbbo5KpYJYLJ5XgGh/ocK3EPuI236RSATMnEc2m42VHwwNDaGyspIFu+TuNDQ05PIDAEePHsX69evnDGy3bt0KPz8//mSnfHx8sHHjRv7kRWFRBLV79uyBVqtFWVkZNBoNrly5glWrVmHNmjXYv38/xsbG0NfXh6effnpet7XJtys1NRUmk4k/GZg5xv7+/tixYwc0Gg2uXbuGvLw8nDt3jh3jsrIyFtR++eWXEAqF7PYeWbrq6+vx4YcfYmJiArW1tfjv//5vh/aCggLI5XKUlZXhrbfeAgA88sgjwMw5pVarUV1djeeffx61tbWQy+UICAhAZWUlG/PYsWPAzJfGPPLIIywA5koTuLFkMpnHwaIzK1euhNlsZtkxeyqVCgEBAbh69Sq/ySmtVouioiJIJBJcu3aNTW9paUFLS4tDX1fmWqa79eWLiopCb28vJicn+U3zGsddX41GAy8vL3R1dfGbHPj7+8PLywuxsbEoKipCUVGRQ2bIZrPh3nvvZW3ubvXPtY/cbbe9qakpLFu2DD/84Q9RVFSELVu2ICwsDL29vbDZbAgODmYXY1FRUfDx8XF5h3Eh9lF7ezuqq6sRGRmJoqIiiEQiHDlyhAW1X3755az6WvLdk56ejqGhIWzZsoXfdFdaNEGtRqOBXC5HQ0MDYmJi+F3IIpeRkQF/f3+XD7Ts2bOHBbFc37n4+PjcUu0jWRqUSiXMZjPq6+vR3t6Oy5cvIyAgAKmpqaivr8cf/vAHVkIwV31YSEgIDAYDC4BTU1NZTe0DDzyAy5cvo76+nj+bR7iM3sWLF/lNwEx2raury+VDPXw1NTU4dOgQ2tvbkZiYCI1Gw+8yJ3fLnGt97XEBo7Nb+PMZx13fsLAwREdHo6Ojw2nG1B6XfeTqVy9fvgyVSsX2kVgsxtTUFA4dOoTGxkaEhIS4vB3qbh+5224+gUAAqVSKqqoqVFZWAna1vefPn4fNZkN2djaKiopgtVqdlhVgAfcRV6bS1dXFamofe+wxh7sc5Lvt1KlTGBwcREdHB9rb291ma+f70GxTUxN/0qKwaILahoYGJCcn4ze/+Q2uXLnC70KWuGeeeQZffvklGhoa8PLLL895m6O3t5c9VUzuXqqZ+khXt5JVKhV+/etfs8xreHg4v4sDs9nMah4bGhowNjYGpVKJ3NxceHt7s7abwWX0nGW/uOxaR0cHv2lOHR0dmJiYmPcF3FzLdLe+9rh6U/tssT1Px8EcfaOjozE9Pe3RMaipqcFf/vIX1pe/j2w2G8u8NjQ0YHR01On+c7eP5tpuZ7q6utj2dXV1QSwWQ6VSobe3F0eOHGEPtQ0PDwN2JQL2FmofhYSEYGJigm1bR0cHbDYbVq5cye9KvqM6OjpYKRN3TrrS1NSEt99+G6dPn0ZnZycsFgumpqaAmbsUN27cQG9vL86fP4+//OUvOHHiBH+IRWFRBLWpqamw2Wx49913XdZjkqUtLy8P165dg0ajwerVq9HT08Pv4iAsLGzOwJcsfe3t7ZiYmHCZuddoNPD19UVZWRmef/55t7flXb2uaGhoCEqlEsuXL8dTTz2FF154ASEhIQgJCZlVv+uOWCxmt8NTUlLg4+ODlJQU9lS8v78/8vLyUFRUhMDAQAQGBrJb1O5w9aPzqdfETFDjaplr1qxxu772wsLCIBaLkZKSgqKiIsTGxsLHxwdarRbf+973PB6Hqzt11TckJASBgYEoKipCXl4exGIxwsPD8f3vf99hHHdGR0cd/tjac3Yr390+SkxMdLnd/Kz5+Pi40/pWm83mNKMqkUictn0b+4h8N0mlUshkslmf4OBgflentmzZgqioKLS2tuK1117Df/7nf+J3v/sd9u7di9/97nf4j//4D7z00kv4/PPPER4ejt27d/OHWBTu2Htqf/jDHyIwMBBfffUVVq5cCZlMhmvXriEpKQnr168HAHz11Vdoa2vDunXrAACffPKJy9vb5M7q7OzEli1b4O3tzS5M1q9fj9jYWHz22WdIT0+Hv78/WlpasHnzZqxfvx7Dw8M4fPgw4uPj8cADD+DKlSvs3bTx8fHIzMzEuXPn6D3Gd4Hw8HDExcXh+vXraG1tZQ8Anjt3DhEREawEQSwWs3eFfvDBB1Cr1YiMjGS12vfffz+8vb3x9ddfA4DDmMuWLUNCQgK8vLzQ2tqKnJwcRERE4Pz58/j4449x6tQp9klOTsb4+Dj279/vMhjma2pqQmNjIxobG3HPPfdAKpXi0qVLqK2tRXt7O2trbGzEihUrMDExgfLy8ll3HLS896GuXr0aYrEYX3/9tcO6LF++HHK5HMPDw05/77lbZldXl9v1tdfb24uLFy+yvmKxGP7+/uxnz9NxhoaG3PZta2tjbX19fQgPD0d/fz8+/vhjh3Ew8+R+Wloaew9sZmYmJBIJ20cKhQJisRjt7e3QaDSIiIjAtWvXZmU/3e2jjo4Ol9vNf7fx2NgY5HI5ZDIZBgcHIZFIkJiYCLPZjMbGRjz44INISkpCW1sbNBoNoqOjYTAYZo2zkPvI398fERERwMzv3+TkZMhkMnzzzTcO+0GhUCAoKAhdXV0en+tkaVi2bBmio6PR0tKCnJwc5OXlsdpulUoFnU6HgIAANDc3Q6VSOTxAxve9730P0dHRSE9PR3p6OrKyspCVlYW4uDikpaVBp9Phe9/7HrKyslgZg6t3yX/n31P7pz/9CWNjYygsLMQvfvELXLt2jdVTnjt3Du3t7QgNDcUbb7zBHiQii099fb3Lk7myshLLly/HG2+8gS1btqCpqQn+/v7IyMjABx98gJ6eHhQWFuL1118HZt6kYLVaKaD9Djh27Bg6OztRWFiIp556CgDw4YcfAnYlBDk5OXj88cfZE+rBwcGor6+H2WzGqlWr8OSTT7IH0pKSkvDCCy8gNTUVZ8+eveka2oX04IMPsmxbTU0N+vv7Wf1lSEgIWlpanNZ83i4qlQpbt26dlZG8k+z30SeffAKz2cwyrPb7qLe3F6dPn0ZAQADLdn7zzTce3bKfD/4+sl+nvLw82Gw2fPLJJwCAixcvwsfHh63P9evXParTnY+wsDBs2bKFZcgbGhrQ3t7Osr4qlQqXLl1a8P1AloahoSHU1dXBZDKxz4ULFzAwMMDv6tSRI0dYwBsUFMQ+XIBs/zzD0NAQjhw5Yjf34nFPZmbmP/kTAcy6wiRkLps2bcKuXbuwf//+Wy4jOXLkCEwmE372s5/xmwghhJDvvKCgIKxfvx5Hjx6FSqWCUCjkdwFm4jmdTof29nan9eWY+RKHr776igWzXDY2KCiIBbvDw8NsDO6BRmfi4+P5k741d6z8gNx92tra8MADDyA+Pv6WgtpNmzZh3bp1ePvttz36qklCCCHku8a+/GDjxo3Q6XRISUmBUqnEmjVrkJKSgtDQUJw/f37O8oPi4mIkJCRg2bJlGBoaQkdHB3u9YEdHBzo6OnDjxg2oVCps2bIFWVlZi7L8gDK1ZEFlZGRgz549+PDDD2/6ncJHjhxBfX09lZoQQgghLthnaucyV6Z29+7dc74yke/555/nTwLucKaWglpCCCGEkCUmKCgIxcXFqKqq4jfNkpaWhqNHj7rM1AYFBSE9PZ09qO/K0NAQ2tvbcerUKZdjUVBLCCGEEELmxb7+1R2upMAT9g+KcbgA1pMxKKglhBBCCCFL3p0MahfFK70IIYQQQgi5FRTUEkIIIYSQJc9l+cHExAR/EiGEEEIIIS75+vryJ31rKFNLCCGEEEKWvEWTqd27dy9SU1NRUVGBAwcO8JvJEqHRaFBSUoLq6mocOnTIYfru3bthNBrx3HPPOcxzKw4ePIiWlpbv7DlTWFgIqVSKjz/+GAaDgd98y5RKJR566CEMDAygrKyM33xL8vLykJSUBACw2WyoqqpCc3OzQx/+8rOysnDffffBy8sLTU1NqKysdOjviZsdQ6lUIiUlBd7e3gCAGzduoLa2FiaTaVb75OQkGhsb2TFRq9WIjY2Fl9f/5BFGRkYcXsOTnZ3NXlhuMplw+vRp1uaMTqeDv78/AODatWuoq6vjd4FOp8PExMRNjyWTybBq1SosW7aM9eWv90Kw33Y42R5X6zfX8bAfl388nHF3DNLS0hAVFQV4OBaHfwz428rhL4+QpexOZmpdfqPY1NQUf9KC27dvH2QyGRobG5Gbm4vw8HBcvXoV586d43clS0RJSQnGxsawf/9+FBUV4dlnn4Wvry/6+vqQlZUFs9m8oH8ULRYLHn74YZjNZo9eNXK3SUhIgEgkwpUrV2A2m/nNTFZWFvR6Pby9vWE0GvnNDuz7ms1mxMbGwmKxzAo4b0VWVhZSU1Nx6dIl/PnPf4ZSqUR8fDyuX7/usB15eXmQyWQwm81obm6GUqmETCbDyZMnb/r3hNFoRHd3N6KiojA0NISrV6/yuziVmZkJs9mMyspK9Pf3IyIiAjKZjJ13q1evxuTkJD7++GMoFApIpVJ0dHRAqVRCrVajs7MT1dXVGB8fh1wuR0hICAwGA9RqNSIiInD58mU2rkAgYMEZX1paGqRSKerr62Gz2RAZGYkbN2447DcuEBwfH3cbfLkbKzg4GGFhYbhy5Qq++OILtLa2LvjPWFpaGkJCQlBfX4/z589DJBJBoVDAy8sLJpPJ5foJhUJoNBqXx4M/rkKhQFhYGIaHhzE+Ps5fDbfHQK1WIzo6GgaDAdXV1fDz80N0dLTLsTjOjoHBYEBrayv7iEQi+Pn54euvv3b780uIK5mZmdBqtUhMTJz1USqVuH79usdJSi8vL8jlcqxcuRJxcXFITk5GUlISYmJiIJfLIZVKIRQKcePGDbcxIneheSfcsfKDgwcPYsWKFezfzz33HPR6/Xc243Y30Ol0UCgUOHnyJL8JDQ0NKC4uXtAsLQBUVVXBaDQiNzeX30QWgMFgwBtvvLHgWdqIiAgMDQ2xLGlZWRneeOMNhwAsISEBISEhsNlsdnPeOSdOnGDZNJPJhNHRUfj4+EAmk0GpVEIkEmFwcBAA0N3dDV9fXyiVShgMBnz00Ucsw2gwGGCxWFg2QyqVYnJyEiaTCS0tLbBYLJBKpXZLdrR8+XJYLBYYDAYYjUZMTk4iODgYmMlebty4Eb6+vrBarfxZZ3E3lp+fHwBgbGyMN9fCqaurw0cffcSOe39/P6anp1l22NX6mUwmt8eDP+7g4CC8vb0hEonslv7/uDsGUqkUVquVXQwajUZMT087zbhiHsdAqVQiMjISXV1dbi88CHElICAAcrkcFRUVTj/+/v7Iz8+HQqHgzzqLWq3Gjh07sHXrVuTk5CA9PR2xsbFYsWIFYmNjkZqaigceeACbN2/Gjh07kJaWxh9iUbgjmdq9e/ciLi4OXl5eSE5ORmJiInJzc7F7927IZDL4+fnhD3/4Ax555BE88sgj+NnPfoYf/ehHSEtLQ1FREX7605/iRz/6EWQyGcvW7Ny5E88++yx+9KMf4dFHH4W3tzcaGxv5iya30aZNmxAYGIiDBw9Cp9OhqKgIIpEIarUacrkcP//5z3Hfffehv78f//mf/4n169fjJz/5CZ544gls2LABISEhePbZZ1FUVIQNGzagvb0dvb29wMxF0C9/+Uv86Ec/wtq1a/HRRx+x5SYnJyM+Pt6h/91KqVTisccewwMPPICMjAx4eXnBy8uLZWoff/xx6HQ6ZGZmIiMjAwKBAP7+/sjKyoKPjw/LQBmNRhQWFmLDhg3IzMxESkoKrl+/Drlc7tA3PDwcDzzwAKKjozE6OorHHnsMarUaDzzwALKzs5GSkgJ/f3/o9XpkZWWxcbisk/36xMXFoaGhgd025rKvrnzve99Dd3c3/Pz8WKZYqVQiLCwM33zzDUwmE/Ly8vDwww+zX7iZmZmQy+VsXPvl269bYGAgYmNj55Wp5VMqlRAKheju7kZQUBCWL1+O69evw2QyQSaTQSqVYmxszGnGVaVSATMvMo+NjcX09DQuXbrE2ry9vZ1mRWUyGRQKBQv0xGIxIiIi8M9//hMGgwGBgYEYGxvD5cuXER4eDqvV6jJgmmsshUKBgIAA9PX1fWtZxMDAQISFhWFkZASTk5Nu14/P/njwM6gJCQmYnJxEfX29w3SOu2PAH1csFiMyMhITExPo6enhD+XxMUhOToa3tzdaW1tnrS8hnvD19UVoaCguXbqEiYmJWZ/ExERUVFRg3bp1GBkZcftzXFRUBB8fH/5kp7y8vBAdHY2amhp+E/BdzNQ+99xzMBgMmJycxOHDh11m7wIDA1FdXY19+/bBYrEgISEBtbW17N9r166FTqfDzp07kZ+fj/r6euj1enR3d0Ov10On0/GHJLeRWq3GwMAAMJNBLS8vh8Viwd///nendYuRkZF45ZVXsG/fPojFYtx///3Ys2cPDh8+jMDAQOTk5AAzF0FisRjPPvssnn32WYjFYuzdu5eNc/HiRfj4+CAlJcVu9LvTmjVrgJnMZmVlpUPmKS8vD76+vigrK8P+/fsxNDSE2NhYNDc346uvvoLNZsOFCxdw5swZ5OXlITw8HCdOnMD+/fsxMTGB9evXz+r71Vdf2S39fwQFBaGqqgonTpyAUCjEvffei6NHj+LcuXMQiUTsxduFhYVsfcrKyuDr64vCwkI2zuTkJH71q19h165d+NWvfoWEhATWlpWV5TKw4/Px8cHAwAD279+PpqYmFpjz98fExATbf7dKqVQiKCgIo6OjLGidnp5mWc2xsTFMT0/z5vofarUafn5+LKsL3jMMntwq5IIgk8nkkMk2GAxoaWmx6zk3V2OJxWJ4e3sjPT0der0eGzduhFKptJtz4XHj9/f3s2mu1s+es+OBmfIGvV4PPz8/dHd3O8zD5+oYjI+PY9myZSzbpVAosGzZMojFYtbHnifHgFvfvr4+pxc9hCyUxMREjIyMID8/n990V7ojQa2nbDYburq60N/fj/HxcVgsFly8eJH9m6NWqzE5Ocl+kbS0tEAkEiE5OdluNHI7aTQaiMVi9PX18ZtcamtrQ1VVFTueRqMRDQ0N6OrqYn+8NBoNFAoFamtr0dDQgIaGBtTW1kKhUECj0bCxfHx83N6yvRsolUpIpVIMDAzAYDCgubnZIVNUWVnJbuErlUq3xfoRERHo6elhGc3Lly9DLBY7BJaucPONjo7CarWy9RkaGmJ3eLh17ejogMFggMFgQEdHB6RSKSIiIoCZ4KCqqgr79+/HyMgI7r//fiiVSihnalBbWlowOjrKW/psNpuNbcfY2JjDXSY/Pz8WZL/zzjsLUkYhk8lY5q+trY3f7JZSqcTKlSsxNjbm9OGuxcTX1xc3btzA6dOn2QVqQkKCy9vutyotLQ0ymWzet+PdHY+6ujqUl5fDaDQiNjYWarXaod0TdXV1MJlMiIqKgl6vh0wmw40bN/jd5oUr8bAP3glZaDU1NTCbzTAajejs7HRbhtDQ0MCf5Nbly5f5kxaFRR3Ujo+Pe/xD7+3tjW3btqG8vJxdkYSGhvK7kSUmODgYYrEY+fn5KC8vZ8dXLBY7/GH4Lty+k0gkEAqFDreQ7P8/KysLO3fuxK5du7B582YIhULWZo8LeJVKJXbt2oVdu3YhIyMDQqHQ4bu+bwW3rklJSWwZSUlJEAqFLMPFD6qFQiEUCgXi4+MxOTmJM2fO8Eadn8rKSjQ1NTmsQ15eHr/bvMhm3ggAwOFJe8zckuPqUP38/NibDjjKmbILi8Uy62FJ+wsQ+//X6XTQ6/XQ6/XYsGEDu3Dj9qFMJvP4luF8x+Ky8dw2dnd3w9vb+7YEtdzbBfhvPoCb9eOmuToe9oxGI6xWK6RSKdRqNb7//e+zfcHVBro6BgBYYF9eXo7W1lZ4e3tjfHwc2dnZbJz5ZLLFYjErqyDkdjEajbh06RIuXbrktvQAAL7++mscOXIEtbW16Ovrw8TEBLvbND09DavViv7+fjQ2NuL48eP47LPP+EMsCos6qJ0PrpSB+wWj1+tdljWQpYMLWCsqKhyO7bZt21hgwAW+dzsuMxoQEMCm2f8/VyO6f/9+HDhwACMjI6zNnsFgwMTEBAwGA/bv388+Bw4cuOVAksOta1NTk8MyXnrpJZw6dcrpLfapqSkMDQ0hIiICUqkUu3btQmFhIfz8/KBUKvH444/zZ5lTZWUlW7bBYEBcXJxH2WhnuADKZrM5BHtwUW5gX47ABbRDQ0OzAlpn+4KbxpXxlJeX48SJE2hra3N6C96Ti7qFGMt+mxZKWloaFAoF2traHAJaV+UG3Pq5Ox58IpGIBaItLS04fvw42xd1dXVujwEfd+Fin8UuLy93eDDNHZlMBolE4nJ8Qm4GV9fv7OOJ/Px8REZGor29HX/+85/xyiuv4MCBAygtLcWBAwfw8ssv491338WFCxcQEhKC4uJi/hCLwh0Larnay4XQ0tICb29vdmvp4MGDKCsrQ1FREb8ruU0aGhowPj6+4NnxhoYGGI1GrFq1ipUbHDx4EG+++aZD+YHNZlvQc2oxMhgMGBgYQHh4OBISEtgtfntcBjYrK8tt1rW7u5uNg5n6V35d663g1jU6Opplrx5//HHs2LEDSqVy1vJjY2MxPj6O5uZmvPPOOywQLSsrw9jYGAwGA9555x3eUtwrLCxky8NMVttqtXpU0uAMV7Pt7AFU7kKBK62IiIhgFw7c7XGLxeL0XaQDAwPsgUq1Wg2RSOT2XB4cHERQUBCUSiUUCgW8vb09vqPF52osmUyGDRs2IDs7G5gJxKKiotg2LRS1Wg2FQgGj0ei0DtXV+mGO45GWluaQOeX+62o/uTsGarUaDz/8MJQzr5OLioqCxWJxur6eEIlE8PLycnuMCZkvjUaDLVu2ICsri30effRRZGRk8Ls6FRAQAK1Wi61bt6K4uJh9Nm/ezKbt2rULxcXF0Gq1/NkXjTsW1HK/ELZt24aDBw/ym+flwIEDqKioQGpqKsrLy6FUKlFVVeXw8n9y+7W0tDgEWY2NjRgfH8e2bduwZcsWh77z8dxzz2F8fBy///3vUV5eDplMhrfffpvVACUnJ8Nmszn943a3KSsrw8jICDZs2IDCwkKHbM/ly5chEolQWFiIpKQk9Pb2siCXu/2akZGBvLw8VFZWoqenBxs2bMCuXbsgl8vx1Vdfobm52aEvF9TcjLKyMkxMTKCwsBC7du2Cv78/vvjiCxgMBlRWVqKtrY0t39fXF6dOneIPcUv4y09ISEBTU9NNB2UikQjLli1zecuZ2/96vR4ikYjVnMlkMgiFQvaWCPsSAJlMhpaWFgwNDSEuLg5xcXEYGhpyGzDV1dXBYrEgPT0dUVFR865BtedqLJPJhNraWkgkEuj1enYeuPoZy87OZg/mcgExd1tfqVTi4YcfdlrPKpVK4eXlxepVuQ+3PFfrp5x5hZqr41FXV4ehoSH2kJtUKsXVq1dd7id3x6ClpQVmsxnp6elz7gdPOCtNIeRWjYyMoLm5GYODg+zT2NiIoaEhflenKioqWIlCQEAA+ygUCvYmFI7ZbEZFRYXd3IvHovlGMbL06XQ6PPHEE3j77bdn3WK9nQ4ePIiBgQEqN/kOyMrKgkajwaeffur2dWBzUc58U1lHR4fTN3MQQshiFxAQgMzMTJw4cQJKpXJWzTnn6tWryMzMhNFoZO9b5svMzMSlS5ccglkA8Pf3Z6Vs3ENnRqOR3WFxhl+T/m2iy0WyYO7EFyHodDqIxWKnX/hACCGEfBekp6dj06ZN2LRpE9avX8/+Pysri9/VKa70IDExEQBw6dIlnD17FhUVFTh79izOnj3Lgtni4mJs3bqVP8SiQJlasqA0Gg1KSkpQXV39rZR/HDx4EC0tLfRNdN8RWVlZuO++++Dl5YWmpqabyrIuxBiEEHKn2Wdq5zJXpra4uNihxMAT+/fv508C7nCmloJaQgghhJAlJiAgAFu3bnX5zV72EhISHOpm+QICApCYmDjnQ2BmsxmdnZ04e/asy7EoqCWEEEIIIfNiX//qDlcP6wn7B8U4XADryRgU1BJCCCGEkCXvTga19KAYIYQQQghZ8lxmagkhhBBCCFkqKFNLCCGEEEKWPApqCSGEEELIkkdBLSGEEEIIWfIoqCWEEEIIIUseBbWEEEIIIWTJW/C3H2i1WqxatQoCgcBh+sDAAN577z2HaYuVQqFAXl4eBgcHcezYMX6zg+3btwOA023Lzc1FbGwsqqur0draym8mhBBCCCEL5LZkaqempnD+/HmUlpaitLQUFRUVkEgkLACcS0FBAZ566imPviWDEEIIIYSQ2xLU8rW2tqK+vh4SiWTO7xVeDIxGI9566605s7SEEEIIIWRxmLP8gLsVL5FI+E0YHR1FZWWlw3cBa7VapKamor6+HjU1NWx6fHw8cnJycPnyZZw8eXLWuFarFdXV1ZDL5UhMTHQYH4DTvvxb+vxSAP665ObmsrEBwGAw4NixY9BqtUhOTsbU1BQkEgl6e3vh5+fHyg9crWtrayu2b98OgUAAgUAAiUTi0MYvP7AvzZiamkJtbS3bR9u3b4dUKgV4+zU3NxdRUVGz9jMhhBBCCPl/5szUGo1GXLt2jT8ZAHDt2jWPA62xsTFYrVb4+/sDAFavXg2r1YrS0lIcPXoUVqsVarUaJ0+ehMFgcAjsXPXl6+npgUQiQXx8PAAgPDwcVqsVnZ2diI+Ph0qlYmURly5dQlhYGOsrFAoxODiI0tJSnDlzxmHcuZYfGBiIa9euobS0FKOjo8jKyppVOhEfH4/U1FS0traitLQUra2tSE1NRXx8PHJzcyEUCnH06FGUlpbCarVi9erVAICTJ0/irbfe8ng/E0IIIYR8F80Z1AJAW1sbRkdHHaaNjo6ira3NYdp8HDt2jGVU/fz8IBQK+V0YT/t2dnYCAORyORQKBZYvX84C79bWVvzxj39kmVEuuOZMTU2hp6fHYRpnruXb74srV65AKBRCLpc79JHL5bBaraxfW1sbrFYr6yeRSBAXFwfMZJqp9IEQQgghxHMeBbXOsrXzydLCLhgcGRkBZt4MUFJSgpKSEuTm5vK7O/C0b2trK3p7exEeHg4/Pz/ALtBVKBR46qmn2DghISG8uV2ba/lWq5Xti6GhIUxNTfG7wN/fHxKJBJs3b0ZJSQk2b94MiUQCf39/nDx5EpcuXUJiYqLb5RBCCCGEEOc8CmrBy9beTJZWLpdDIBBgbGwMCoUCUVFRMBgMKC0txQcffACr1cqfBZgJRj3ti5kSBJFIhNjYWFitVlZ3GxcXB6FQiIqKCpSWluLq1av8WZ2a7/KDgoJmvc4MAEZGRjA6OspKDLgPl5E9efIkm2YwGBAbG8tKIwghhBBCiHseB7X22dr5Zmnj4+MRGxuL4eFhh4fHuGxqXFyc0wfR7Hnat7OzE1NTU4iKisKVK1cc2gQCAYKCgligOh/ulh8YGMje6hATE8PqeO11dnZCKBSyEgOtVounn34aubm5s15hNjIyAqvVirGxMYcxCCGEEEKIcwKFQrGHP9EVm82GwMBANDQ0wGw285uBmcwmV9OakZGBjIwMxMTEoKurC3/7298AAGazGVKpFFFRUcjIyIBAIIDFYoFQKERjYyOCgoIQFRWF2NhYdHV14Z///KfLvnxmsxkrVqyAt7c36uvr2XrabDZERUVBpVLh3nvvRXd3NwICAjA8PAzMPFTW29uLzs5OBAQEYOXKlbhx4wbOnz/vdl1TUlIwOTmJ0NBQrF27FgKBAJ9//jna29uhUqkglUrxzTffoLW1Fd7e3khJSUFmZibkcjk6Ozvxj3/8A62trUhMTER6ejoyMjIglUrR2NiI5uZm5ObmIicnByaTyeU+J4QQQgj5rpvzlV6EEEIIIYQsdh6XHxBCCCGEELJYUVBLCCGEEEKWPApqCSGEEELIkkdBLSGEEEIIWfIoqCWEEEIIIUseBbWEEEIIIWTJo6CWEEIIIYQseS7fUzsxMcGfRAghhBBCiEu+vr78Sd8aytQSQgghhJAljzK1ZEFpNBqUlJSguroahw4dcpi+e/duGI1GPPfccw7z3C47d+7E2rVr8corr6CqqorffFOKioqg1+tRXl7usH3zdfDgQbS0tODAgQP8prtWYWEhlEolbDYbxGIxent78c477/C73RJuGZj5auyqqio0NzfPagOApqYmVFZWsn97Ijs7GzKZDABgMplw+vRpfhcAgEwmw6pVq7Bs2TIAwMjIiNNzkOs3OjrKxuLPy19OWloaoqKiAACTk5NobGyEwWBg7fY8XV8A0Ol08Pf3BwBcu3YNdXV1Ttv422K/DMwxL7/Nvs/ExITb9btZc62fPft9CwDT09O4fPkyxsbGkJKSAm9vb4f+zva/Wq3GypUrcfXqVbS0tDj0h5Pjy9+ffK72PX+7ONxxdrUtztaJkIV0JzO1AoVCsYc/EQCmpqb4kwiZU0lJCcbGxrB//34UFRXh2Wefha+vL/r6+pCVlQWz2ez2F/hC0mq1iIqKwoULF9DR0cFvZnQ6Hf7whz8gIiIC586d4zc70Gg0iI+PR2trKxobG/nNHrNYLHj44YdhNpvdrtvdIiEhASkpKWhpacHhw4cRExMDAGhoaOB39VhCQgIee+wxBAYG4urVq8jLy8OKFSvwySef4Pjx41Cr1VCpVLh+/ToyMjIc2vz9/ZGQkACBQACj0cgf2im1Wo2IiAhcvnwZ/f39iIiIgEAggMlk4neFVqvF9PQ0Pv74Y4yPj0MulyMkJGRW8JmWloaAgACMj4+zNq1WC4FAgHPnzsFgMGDFihXw9/dHT08P1Go1oqOjYTAYUF1djZCQEMjlcgwPD2N8fNxh7Pmsb1paGqRSKerr62Gz2RAZGYkbN27AbDYjOzsb/v7+qK+vx/nz56FSqRAZGQmDwYC0tDSEhISwNpFIBIVCAS8vL5hMJrfjcrigzX4fLJS51o9v5cqVmJqawscff4zW1la0tbXBZDLBbDbj66+/RmtrK1pbW9Hf34+QkBCYzWY0NTWx+WUyGdRqNby9vTEwMOB0GZ6eG5gJXF3te4PBwNantbUVIpEIfn5++Prrr2E2m11uC7m7ZGZmQqvVIjExcdZHqVTi+vXrHicpvby8IJfLsXLlSsTFxSE5ORlJSUmIiYmBXC6HVCqFUCjEjRs33MaI/Iu/bxOVH5AFo9PpoFAocPLkSX4TGhoaUFxc/K1laRe7qqoqGI1G5Obm8pvuWlNTUxgbG+NPXjCVlZV46aWXWGa2u7sbQqEQEolkVltnZyempqbg5+fHG8U1qVSKyclJmEwmtLS0wGKxQCqV8rsBM8eXu3gzGAywWCyzshdKpRIBAQGYnJx0mCYSidDX1weTyQSTyYS+vj4sX74cmFmHsbExlmk8ffo0Tpw44TRYmc/6Ll++HBaLBQaDAUajEZOTkwgODoZMJoNEIsHQ0BALurq7uyEWiyGTyVBXV4ePPvqItfX392N6epplIV2Ni5lt3bhxI3x9fWG1Wu3WZuHMtX58vr6+HgUAcXFxAIC2tjaH6QqFAt7e3piennaYbs+TcwMzAbK7fW9PqVQiMjISXV1drK+n20KWroCAAMjlclRUVDj9+Pv7Iz8/HwqFgj/rLGq1Gjt27MDWrVuRk5OD9PR0xMbGYsWKFYiNjUVqaioeeOABbN68GTt27EBaWhp/iEXhjgS1Go0Gb775Jvbt24fDhw+jvLwcb775JjQaDTBza/a1115DWVkZm15UVISysjKUl5ejrKwMRUVFbDydTsfGKS8vx86dO+2WRr4tycnJGB8fR1VVFXQ6HfR6PUQiEbZu3Yp/+Zd/wZtvvom9e/e6PP47duxgx9j+fMDMOcEd34MHDzos11M7d+5kY5SXl7N1eeKJJyASiZCfnz/vc8fVeVlUVITDhw/jtddec7nefX19UCgUDtt5N0pISIBOp8OyZcuQkZGBwsJCfhcUFhZi165d2LVrF3bs2OFQJpCXl8fadu3axcoI7r//fvj4+CApKQl5eXkO4wFAREQERkZGWCB7q3x9fWGz2RwCSGfBCB8XqA4ODjpMj42NxfXr1x2CWld8fHwQFxcHiUTicaDi6frKZDL4+PjMGlcsFjv82563tzdEIhF/sgNPxr169SouXLjgNgj8tnDrOxelUomgoCB24WE/PTQ0FF1dXQ793XF1brjjbN8rlUpMTk6yuw6ebgtZ+kZGRmA2m51+AKCiogJarXbOwPahhx6adV654u3tjZycHP7kReGOBLWcFStWoLy8HM8++ywA4Be/+AVrCwwMxIEDB1BcXIzg4GDo9XpUVVU5/Fen07GgpK2tDXq9HocPH8batWsdgl7y7VCr1RgYGABmshHl5eWwWCz4+9//7rR2MTIyEq+88gr27dsHsViM+++/H3v27MHhw4cRGBjIfmj27t0LsViMZ599Fs8++yzEYjH27t3LH84tnU4HrVaLw4cPQ6/Xo6KiAnFxcQgODsbbb78Ni8WCioqKedW4coE7dz42NTWx8xIzgYjNZmPnZUREhEPQfPHiRfj4+CAlJcVu1LtPc3MzqqqqYLPZ0NTUhLKyMof2vLw8hIeH48SJE6xt/fr1wExAHBMTg3PnzmH//v1oampCeHg4JBIJvvjiCzam/fnFBcFBQUG4fPkym24vISEBmMnYzod9gMYP1pzR6XRIT093CDgw87MiEAjQ19fn0N9isWBychKhoaGQyWSQyWQIDQ2Ft7c3yy5OTU1h48aN0Ov12Lhxo8MFAN981pcrXzCZTLDZbA7/HxQUxJYTEREBb29vp1lurk9/fz+b5mxczGQpv+36TmfrxxGJRPD29oZMJoNer4der0d2dja/26wA0n766Ogobty44TDdFVfnBsfTfe8syPZ0W8jdLzExESMjI8jPz+c33ZXuaFDb3d2NQ4cOoaGhAbW1tZDJZCwgMJlM7BYNlwGsrq4GAFRXV2N8fBzJyclISUmBWCxmvxwPHTqEbdu23dJDPGT+NBoNxGLxrD/S7rS1taGqqgr9/f0YHx+H0WhEQ0MDurq62B8/jUYDhUKB2tpaNDQ0sHNlvhnOqqoq/PjHP2bnRWhoKL/LvCUnJwMzwSkAVnbBTbfZbOzBF/ttsufj4+PylvB3hX1G1WAwoKOjg9W8Njc349VXX8WZM2eAmdttc6msrMT+/fvR3NyM++67D1lZWQ7teXl5UCqVaGtrW7AsrivcxZ3NZsOqVatYoKpQKGA0GmGxWBz6m0wmNDc3w9vbG9nZ2cjMzJxVKxscHIzGxkZ20ZiQkDDrdvRCamxsxOTkJNLT06HX62Gz2ZxmVtPS0iCTyRxugS8mc62fn58fvLy8cO3aNZSXl6OtrQ1SqdThNitXEjA6OuqQpVWr1RCLxbPKEdxxdm7webLvuXIO+0Ddk20hd7+amhqYzWYYjUZ0dna6zdbO9/kGVwmDO+2OBrVcVo/7f2d/9DETgAQHB+P3v/89ysvL8fvf/x7BwcEIDQ1lAcF8bvmQpSM4OBhisRj5+fnsNn5+fj7EYjH7Ze4JruSBG2PlypX8LvMWGhqK8fFxp1kfT3DB/HeZUqmEr6+vy1pbpVKJHTt2sNKDkJAQfheXWltbYbFYEBERwabl5eUhKSlpVnbXU/a3753dynelu7ubZc4UCgWmpqZcZikNBgM++ugjlJeX4/jx45iensbk5CTLAPJrLLlxnZnP+nJlAfxb1yaTCSdOnGA/O6OjowDgcMy4J+2dvVnA1bjfJnfrx2lpacHx48dZe0tLC8bGxlg9M2YyoF5eXg5/uzBzYcbVQM+Xu2Poyb4Xi8WsbpnjybaQu5/RaMSlS5dw6dIlh4cznfn6669x5MgR1NbWoq+vDxMTE+wCanp6GlarFf39/WhsbMTx48fx2Wef8YdYFO5oUGufoZJKpS5/4fX19aG/vx/PPvssu5Wi1+vx3HPPsV8ukZGR/NnIXYAL/CoqKhyO/bZt21gm3xM5OTkQi8XYt28f9Ho9zp49y+8yb319ffMOru1xAft3mcFgwMTEhNNb2QAQHx8PoVCIEydOYP/+/bhy5Qq/i0sSiQRCoZD9Ms/Ly0NCQgLOnTt3UwGts9v3zqY5w5UOcIGFv78/uyW8bNkyh7tUfFxtbFtbm9ML/+npaacXBc7Wzdk0flkAx9UFl1gsxuTkJMsyp6WlQaFQoK2tzSFgnO+4t4ur9fOU/T4LDg6Gl5eXw/7m6mKjoqKg1+sRFxcHb29vxMXFeZQZtT835sLf91zm2NlxdcbTfmTpCQoKwvLly51+PJGfn4/IyEi0t7fjz3/+M1555RUcOHAApaWlOHDgAF5++WW8++67uHDhAkJCQlBcXMwfYlG4o0Et94tco9Fg1apVDiUH9i5evAixWMxqLLmHc3bu3InGxkaMj49DrVYDdg+NzfeBH3JrGhoaMD4+viC39e01NDTAaDRi1apVDg8S8h8k84SPjw8iIyPZ+XaruLIDrtyAe5MBN90TNpttVtbnu6a7u5uVGyiVSkRHRzs84CUQCFhdYXR0NH92Ji8vD7/61a9Yvax93WxWVhYrZ+BKGeZrYGAAIpEIarUaarUaIpHI5bHT6XQsSJXN1MVy2TTutnN5eTlOnz6NGzduOPzu0+l0rP4xLS0Nfn5+6O7uBgAMDg7OqrGcmJhwejt9PutrPy73BD93ByI7O5tti1qthlQqZfWbarWalVI4yzy7G/fbMNf62UtLS3OoUeb2vf0+c5YVtc+sc7f6JycnXQbR7s4NPnf7Hm4yx55sC7m7aDQabNmyBVlZWezz6KOPIiMjg9/VqYCAAGi1WmzduhXFxcXss3nzZjZt165dKC4uhlar5c++aNzRoHZ4eBg7d+7E73//ewDAq6++yu8C2NUe6XQ6lJeXY9u2bWhqasKBAwfQ0NCAt99+G3FxcSgvL8fu3bvR1tY2rwd+yMJoaWlxyL5zFxzbtm3Dli1bHPrOx3PPPYfx8XFWfiKTyfD222+joaEBO3fu9CjAra6uxvDwMLZt24Y9e/awjF9kZCSqqqpgMpmQn5+PvXv3ejwm/7xMSkpCeXm50wszZ5KTk2Gz2W7pfbd3g8rKSvT09GDDhg3szQinTp0C7EoIMjIysHnzZlazHRQUhObmZoyMjCApKQmFhYUO4+zatQtyuRxfffUVmpubERERAS8vLyQlJc16k4KnWlpaMDQ0hLi4OMTFxWFoaIgFSjKZDBs2bGCZucbGRvj4+Dg8oOPpcb58+TKCgoKg1+sRFRXlEJDV1dWhq6uL1Vj6+Pi4HNfd+iqVSjz88MMsGVBXVweLxYL09HRERUU51J22tbWxbYmLi8PAwAAL1qRSKby8vFiWkvtw2+xu3PlIS0vDhg0bIJupSbbf1/xtsTfX+tkHjfx9y9/38KCEwxPuzg3+trjb97CrneXzZFvI3YVLBAwODrJPY2MjhoaG+F2dqqioYHe1AgIC2EehUEChUDg8z2A2m1FRUWE39+JxR75RTHMHvl2K3H46nQ5PPPEE3n77bY8Du1ulmXndG/fA4UK4HWM6c/DgQQwMDNDPACGEkHkLCAhAZmYmTpw4AaVS6bKE8+rVq8jMzITRaHT6pg3MfInDpUuXHIJZAPD398fIyAgwE8xyY3B3QJxZiIu/mzX7Eo+Qm1R1B75QICUlBSMjIwsafN6OMfl0Oh3EYrHTL6oghBBC5iM9PR2bNm3Cpk2bsH79evb//Le/uMKVHiQmJgIALl26hLNnz6KiogJnz57F2bNnWTBbXFyMrVu38odYFChTSxaURqNBSUkJqqur6bVqbhw8eBAtLS1UJkMIIeSm2Gdq5zJXpra4uNijVyba279/P38ScIcztXckqCWEEEIIITcvICAAW7duRU1NDb9ploSEBIe6Wb6AgAAkJibO+RCY2WxGZ2cnzp4963IsCmoJIYQQQsi82Ne/usPVw3rC/kExDhfAejIGBbWEEEIIIWTJu5NBLT0oRgghhBBCljwKagkhhBBCyJLnsvygtbWVP4kQQgghhBCX4uPj+ZO+NZSpJYQQQgghSx5lasmCysjIwJ49e/Dhhx/i4MGDDtNffPFFtLe342c/+5nDPLfLnj178NBDD+HFF1/EBx98wG++Kc888wx+/OMf491333XYvvk6cuQI6uvrsWfPHn7TXevJJ5/EypUrMTExAT8/P3R3d6O0tJTf7ZZwy8DMw64ffvgh6uvrZ7UBQG1tLY4dO8b+PReVSoU1a9awb+0ZHx/H6dOn0dvbC61Wi9jYWP4sGB4exvHjxwEADz74IMLDwwHevHxhYWHIzs6GWCwGAPT09OCTTz7hdwN4Y2LmK3btX+/jbpkajQaJiYkQCASz2lzRaDRQq9VoaWlx+uUk7vYReMucmprCpUuXHMb5/ve/j8DAQMDJttizX47NZsP58+fR3t7O73ZLFnJb7M8DvoU83u6WOdf6cvjL4LhbL0Ls3clMrUChUDj9q9rf38+ftKCOHDmCH/7whzh8+DC/iSxhe/bswcjICJ577jk888wz+L//9/9i2bJl6OrqwoMPPoihoaEFCzDnsn79esTGxuKzzz5DW1sbv5nZtGkT/vu//xtKpRKnTp3iNzvIyMiARqNBQ0MDzp8/z2/22Pj4OB577DEMDg66Xbe7RWpqKlavXo2Ghga88cYb7Ftrzp07x+/qsdTUVPz0pz+FVCpFa2srCgoKEBMTg/LycvzlL39Bamoq4uLi0NPTg5ycHIe2wMBApKamQiAQeBwM6XQ6DA0N4dixY+jr64NSqUR4eDja2trQ2dmJxsZG9rnnnnsglUpx5coVFvTK5XI0NTWhsrISsbGxkMvlTo+9TqeDQCBAdXU1rl69itjYWAQGBqKzs9Ohn1arRUREBGpqavDpp59CLBZDpVLBy8uLLZNrb21tdVjfsLAwpKamYnBwEGfPnoVSqURgYKDbfcHN4+Pjg+vXr88KgMPCwrBmzRqX+0ilUiE1NRUdHR34//6//w9hYWGIiorC+Pg4hoaGoNVqERISgpqaGkxMTGDFihWsjW/t2rWw2Wz4+9//DpVKhdDQUKf78mZ5ui0mkwnHjh2Dl5cX7r33Xty4cQNDQ0N48MEHIRaLUV1djZ6eHkRHRyM8PNzp/l2o4/3ggw8iMDCQtcfFxUGpVKK9vX3OfW+vvb3d4VwWi8Xw9/dHU1PTrL7kztPpdFi/fj3S0tJmfaKjo9HT04MbN27wZ3NKIBAgOjoa8fHxSElJwerVq5Geno6EhASsWLECISEh8PX1xfj4OCYnJ/mzMzKZjD/pW0PlB2TBbNq0CSqVCuXl5fwmnDt3Dnl5ed9alnax++CDD9De3g69Xs9vumtNTU2x7xC/HY4dO4YXX3yRZWYNBgN8fX0REBAwq62jowOTk5Pw9/fnjeLakSNHWKaqt7cXZrMZPj4+CAsLc+gXFhaGmJgY9Pf3s0xYSEgIrl+/zv59/Phxp5k7lUoFsViMrq4u9Pb2ore3F11dXQgJCeF3RU1NDf7617+yQKmvrw/T09MQiUQAAIlEApvNhvHx8VnrGxYW5hCcdnV1ISAgYNa22IuOjoaPjw+mp6f5TcDMPnG3j7h9bbFYAADXr18HZr5bHjP7aHx8HO3t7ejo6IDNZkNoaCgbn8PtI27+a9euwdfXFyqVit/1ps21Ldx6Xb16FQDQ0NCAiYkJNl0kEsFms6G3txft7e0YHx9nx8XeQh3vsLAwBAQEoL+/n7Vfu3YNfn5+Hu17V1QqFVasWIFvvvnGaUBO7qygoCCsWLECR48edfoJCgrC5s2bER0dzZ91Fo1Gg1//+td46qmnsHHjRmRlZSExMRH33nsv+1KGhx56CI8//jj+9V//dc4vabhT7khQ+/rrryMmJgYxMTE4cuQI9uzZgzNnzuDw4cNoaGhAQ0MD9uzZgyNHjjj8m7Nnzx42vaGhAa+//jow80fnzJkz2LRpk0O/79It3jtp9erVGBkZwQcffIBNmzbhxz/+Mfz8/PCTn/wEL774IiorK/H6668jIyMDlZWVOHz4MM6cOYOGhgZUVlbif/2v/4Uvv/yS/TsjI4ONbX8uHDlyxGG5nnJ23mRkZGDXrl3w8/NDYWHhvM+VZ555hq3zl19+iWeeeYZNP3PmDD766COX693Z2QmVSuWwnXej1NRUPPLIIxCLxcjJycGTTz7J74Inn3wSL7zwAl544QX8+te/dghQCgoKWNsLL7yAJ598EiqVCnl5efD19cWqVatQUFDgMB4AKJVKmM1mFsh+W7jgjwt4uMBldHSU39VjzoLnuYyOjsLHxwdisZgFPWazGb29vSzAsr/I4Po6o1KpEBkZiW+++Ybf5DFuWdyyQ0JCWODHBdlc0MWRSCQO/4ZdIGbfVyAQzBmgfRu49bVYLOyY8YNwT9zM8XaGO6bu9r07K1euhM1mQ0dHB7+JLBJDQ0MuPwBw9OhRrF+/fs7AduvWrfDz8+NPdsrHxwcbN27kT14U7khQ+7Of/QxXrlzBlStXsGXLFgCAn58fzGYzNBoNampqUFhYiPr6emg0Gly5cgVr165FRkYGNm3ahNzcXLz66qvQaDQoKytDcnIyNm3ahC1btqCnpwc/+clPsGnTJjz00EMoKyubd6BCbg53Ow4zmch3330XY2Nj+NOf/oSjR4/yuyMqKgovvvgifvOb38DPzw/5+fl4+umn8eqrr2L58uXsh+b111+Hv78/duzYgR07dsDf359dyHjK1XkTFhaG/fv3Y2xsbN7nChe4f/DBB9BoNKitrcWPf/xjdlElFAoxMTEBjUaDV199FVFRUQ7jf/nllxAKhVizZo3dqHef+vp6fPjhh5iYmEBtbS3++7//26G9oKAAcrkcZWVleOuttwAAjzzyCDBzTqnValRXV+P5559HbW0t5HI5AgICUFlZyca0r43lgmCpVIpLly6x6fbS0tKAmYztzVCpVAgODmZBIicsLAyRkZEOGTPMZKmXLVuGH/7whygqKsKWLVucBi3j4+Ow2WyIjIxkGdXIyEi3ASeHqxfu6+sDZjJ7LS0t0Gq1yMvLQ1dXl0NNJJfFxUwQNjU1xdr4Vq5cCbPZPCvodIe/j9rb21FdXY3IyEgUFRVBJBLhyJEjDvuPC/x7e3ths9nsRnNkn/UfGRlxu+4Lgb8tFosFXl5ebJ9rNBpIJBIWNH7yySfo6upCXl4etFotWlpanNYHL9Tx5vZXcHAwuyCMioqCj48P/P39Pdr3fNw2c1lksjSlp6djaGiIxVp3uzsS1DozNjbGblt3dnZibGwMX375JQCwQAkzwdK6devYQzpyuZy1AcCf/vQnhIeH43//7/+Nnp6eeQUp5OZlZGTA399/Vh2YOxcvXsQHH3yA3t5ejI2Nob29HefOncO1a9dgtVqBmXFVKhU+//xznDt3DufOncPnn38+7wznXOfNzVi9ejUwE5wCYOcvN91qtaKyshKYuRXIbZM9Hx8fp7cav0vsM6rt7e24fPkyAgICkJqaivr6evzhD3/AyZMngZnbbXM5duwYnn/+edTX12Pt2rXIzc11aC8oKMDKlSvR1NR0U1ncsLAwpKWlwWaz4eLFi7PafGZu69sTCASQSqWoqqpi54Szi5ne3l7U1dXBx8cHeXl50Ol0GBsb43ebRavVIjw83OE28YMPPgi1Wo2amhocOnQIISEh+P73v8+fdU4ajQZ+fn6zttUdZ/tIo9FAp9Ohq6sLhw4dwvXr1/HYY48taNnA7eBsWxoaGtDe3o7w8HAUFRUhJiaGXSBg5oGtyMhIVFZWoqqqCjExMXjwwQftRv0fC3m8z58/D5vNhuzsbBQVFcFqtbJSkZvZ91wpBXeRRJaeU6dOYXBwEB0dHWhvb3ebrZ3v8w1NTU38SYvCoglqPcXduuZu6fKfsvvggw9w8eJFliEkS1tYWBgrDeCOeWFhIasV89Rc583NkMvlGBsbu+ksBhfMf5epVCr4+vq6rLVVqVT49a9/zUoPnD2V7UpDQwPGxsagVCrZtIKCAqxatWpWdtdTYTNPqgNw+rYA+1pKPn7dJPegD197ezv++te/4tChQ/jLX/6Cqakph6wqH/fmBfsn4cNc1FiKxWJoNBqAV24gEokgEAjsRv1/oqKi2Hp7wtU+CgkJwcTEBMuOc3Wz9m+k4G7fcxcHrtiXG/j7+7tc91vlalswkwk/dOgQDh06hNOnT0MgEMBisbByA/7xts+i2luI4w27OmBunYaHh4GZTLYn+55PIpGwGmeyNHV0dKCurg51dXXsfHClqakJb7/9Nk6fPo3Ozk6HuzdTU1O4ceMGent7cf78efzlL3/BiRMn+EMsCksuqN24cSP8/Pzwm9/8BhqNhmVwOM888wxWrVrFajnJ0sYFfmVlZdBoNOyTlZU1r7cozHXe3IzOzs55B9f2uID9u6y9vR0TExMu6yE1Gg18fX1RVlaG559/Hi0tLfwuLgUEBMDX15fVlhUUFCA1NRXV1dW3FNDabDaXt26d1Spyt5j53AUu9twFylqtFiqVCo2NjU5vb7virNzA2fpwAVpsbCyKioqQkpICHx8fpKSkOH1QxJN95Eyvi3IDZ3XIzsoNbsdDiPPZFrFYDB8fH6frO18LdbztHxScL+6iaD7lJuTOkkqlkMlksz7BwcH8rk5t2bIFUVFRaG1txWuvvYb//M//xO9+9zvs3bsXv/vd7/Af//EfeOmll/D5558jPDwcu3fv5g+xKCy5oBYztYpRUVHIyMjA2rVr2fSMjAxs2bIFtbW1+M1vfoPw8HAqP/iWnDt3DiMjIwtyW9/euXPn0N7ezmqqMfPQGP9BMk+4Om9uFld2wJUbcG8y4KZ7wmazzbpV/V1jMBhYuYFKpUJsbKzDA17e3t4sy+XsXbCcgoIC/Pu//ztSU1MBXt1sbm4uK2e42QsarlzA1avcXJUe9M48Oc+vm+TX43K+//3vs1vVWq0WEokE165d43eDRqOBSqVCe3s7GnjvG+WWya+x5IKl3t5eTE9PY+XKlW7Xxz6LeOjQITQ2NsJms7kMqtzto+vXr8PX15fdAo2Ojoavry/bX9evX2fryz1s5+zWN3chFBUVBcxs18TExIJnFN1ti0qlwtatW1nWOykpCbaZB6raZ952wD/errKeC3G8MVNuwpWXaDQahISEsGzxXPueTywWw8vLy2U7WXwyMjLwxBNPIDc3l31+8pOfICcnh9/VqaCgIKxfvx7FxcXYvXs3+/z4xz/GU089hd27d+OFF17A7t27sX79ev7si8YdC2rr6+sRExODysrKedUUfvTRRxgcHMQvfvELvPzyy2hubgYAZGVl4cUXXwRmHiz64IMP8PHHH2PTpk3siXRye9XX1zu8n+78+fMYGxvDL37xC6dPvHvqZz/7GUZGRvDGG2+goaEB4eHh2L9/P86dO4c9e/Z4FOC6Om+ioqLwwQcfoKenB4WFhXj99dc9HpN7GG7Tpk1oaGjAqlWr8O6773qcQV69ejWsVqvTP5rfJceOHUNnZycKCwvx1FNPAQA+/PBDwK6EICcnB48//ji6u7sBAMHBwaivr4fZbMaqVavw5JNPOozzwgsvYMWKFTh79izq6+uhVCohEAiwatWqWW9S8JRYLIZYLEZeXh6KiopQVFTkUJfIZeuc+eSTT2A2m5GXl4e8vDzYbDb20JZWq3V4cKypqQnBwcEoKipCbGysyyAmJCQEAoGAZVG5DxcgffLJJxgfH2c1lj4+PuwWem9vL65cuYKQkBDk5eUBMzXumAnOt2zZ4jQT6w6X1XW1j7g6VG59VSqVwxcA1NTUsPWNjY11qBd1to/EYjGKioogFotd1vfxt4UfjNoHgvbm2pb29nYYjUakpKSwdairq2MXBdzPtP3x5l7h5mxbFuJ4X7x4ET4+Piiayahfv36dXXi42/f8fYTbXNJBbo+hoSHU1dXBZDKxz4ULFzAwMMDv6tSRI0fYXa2goCD2UalUUKlUDs8zDA0NzXqbz2JB3yhGFsymTZuwa9cu7N+/3+PA7lZlZGSgpKQEpaWl8y50d+V2jOnMkSNHYDKZ6N29hBBC5o3Lrh49ehQqlQpCoZDfBZiJ53Q6Hdpn3gHtjE6nw1dffcWCWS6rHxQUxILd4eFhNkZ0dLTLsRbimZWbdccyteTucye+UGDNmjUYHh5e0ODzdozJt2nTJvj7+zv9ogpCCCFkPrKysrB9+3Zs374dGzduZP/v7K0bznClB1zZVl1dHU6dOoWjR4/i1KlTOHXqFNpnvp1u9+7dKC4u5g+xKFCmliyojIwM7NmzBx9++CF7fRaZ7ciRI6ivr6eab0IIITfFPlM7l7kytbt37/bolYn2nn/+ef4k4A5naimoJYQQQghZYoKCglBcXIyqqip+0yxpaWk4evQoKyXgCwoKQnp6+pwPgQ0NDaG9vR2nTp1yORYFtYQQQgghZF7s61/dGRoacpml5bN/UIzDBbCejEFBLSGEEEIIWfLuZFBLD4oRQgghhJAlz2WmdmJigj+JEEIIIYQQl3x9ffmTvjWUqSWEEEIIIUveksvU7ty5E2vXrsUrr7zi0RN/5Nul0WhQUlKC6upqHDp0yGH67t27YTQa8dxzzznMc7vcjnOlqKgIer0e5eXlDts3XwcPHkRLSwsOHDjAb7prFRYWQqlUwmazQSwWo7e3F++88w6/2y3hloGZryCuqqpi3x5n34aZb3KqrKxk/56LUqlESkoKvL29AQA3btxAbW0tTCYT0tLS2Ne22hsZGUFVVdWseU0mE06fPs3vzuh0Ovj7+wMArl27hrq6On4XAEB2drbDt/hxfWUyGVatWoVly5Y59J+ensbly5fR0tLiMO/k5CQaGxthMBgc+nPs14fbJmf422m/j/jryuH2BX/eufYRR6fTAYDLdbpZ/PWx3xZn7fbHib//3W3LfPry9yH/3LBv56+v/Tnq7njzl8Fxt16E2LuTmVqBQqFw+qLMqakp/qQFdfDgQTzyyCP46KOP+E1uabVaREVF4cKFCx49hUe+XSUlJRgbG8P+/ftRVFSEZ599Fr6+vujr60NWVhbMZvOC//FxxdNzRafT4Q9/+AMiIiLm/MIFjUaD+Ph4tLa2orGxkd/sMYvFgocffhhms9ntut0tEhISkJKSgpaWFhw+fBgxMTHAzNd33qyEhAQ89thjCAwMxNWrV5GXl4cVK1bgk08+wfHjx6FWq6FSqXD9+nVkZGQ4tPn7+yMhIQECgQBGo5E/tFOZmZkwm82orKxEf38/IiIiIJPJ0NHRgZ6eHrS2trLPPffcg8DAQBY0aDQaNu8999wDuVwOsViMnp4e/mKQlpYGqVSK+vp62Gw2REZG4saNGzCbzbP6hYSEoL6+HufPn4dIJIJCoYCXlxeuXbuGK1euOKxTZGQkbDYbLly4MGtehUKBsLAwDA8PY3x83GE52dnZ8Pf3Z31VKhUiIyNnBUQymcxhO/n7yGAwOKyPSCSCn58fvv76awiFwnntI05aWhpCQ0NhtVoX9Odorm3ht9vve5PJBK1WC4FAgHPnzsFgMGDFihXw9/d3ui2e9uUfM/4y7dvb29sd1letViM6OhoGgwHV1dXw8/NDdHS00+Pt7jjxz0Fy52VmZkKr1SIxMXHWR6lU4vr16x4nKb28vCCXy7Fy5UrExcUhOTkZSUlJiImJgVwuh1QqhVAoxI0bN9zGiNyF3p2w5MoPDhw4gG3btn1rgRHxnE6ng0KhwMmTJ/lNaGhoQHFx8beWpV3sqqqqYDQakZuby2+6a01NTWFsbIw/ecFUVlbipZdeYpnZ7u5uCIVCSCSSWW2dnZ2YmpqCn58fbxTXTpw4wTJVJpMJo6Oj8PHxmZXVkslkiIqKwtDQEFpaWmAymWbNa7VaIRaLHebjLF++HBaLBQaDAUajEZOTkwgODuZ3Q11dHT766CMWXPb392N6enpWdhYzAZFIJMLly5cBJ/MODg7C29sbIpHIYT6ZTAaJRIKhoSHWt7u7G2KxeNZ2O9tOV/tIqVQiMjISXV1dMBgMTud1t48ws24ymQyTk5P8plvmbH3st0UkEsHb25sFhPb7XqlUQiQSoa+vDyaTCSaTCX19fVi+fDlvKf+zHzztyz9m/OMtFosxOTkJi8Uya32lUimsViu7gDMajZienp51XPj4x4ksLgEBAZDL5aioqHD68ff3R35+PhQKBX/WWdRqNXbs2IGtW7ciJycH6enpiI2NxYoVKxAbG4vU1FQ88MAD2Lx5M3bs2MG+eWyxuSNB7d69e6FUKqFUKnHw4EHs3LkThw8fxr59+1BeXo7y8nLs3LkTBw8edPg3Zm4pHz58GDqdDgcPHsSbb76Jw4cPo7y8HGVlZSgqKuIvjnxLkpOTMT4+jqqqKuh0Ouj1eohEImzduhX/8i//gjfffBN79+6FRqPBm2++iX379rFj9+abb2LHjh0oKytj/9ZoNGxs+3PhZr+pbOfOnWyM8vJyti5PPPEERCIR8vPz2XnmqaKiIrbO9udfUVERDh8+jNdee83levf19UGhUDhs590oISEBOp0Oy5YtQ0ZGBgoLC/ldUFhYiF27dmHXrl3YsWOHQ5lAXl4ea9u1axcrI7j//vvh4+ODpKQk5OXlOYwHABERERgZGWGB7LdFoVDA29vbZRAgk8ng7e2NgYEBfhNkMhl8fHxmZVbcBXdzkclkCA0NdQhM+ewDaU84C4DnQ6lUYnJy0mWW3N0+4sTFxWF8fBwWi4XfdNtZLBZMTk6y48JddPT39/N6/j/OgntX5tOXMz4+zo4LdzEyOjoK00z5AZ+Xl5fTCyB7cx0ncueNjIzAbDY7/QBARUUFtFrtnIHtQw895PHPtLe3N3JycviTF4U7EtQ+99xzMBgMMBgMeOaZZwAAIpEIo6Oj0Ov1qK+vR35+PlpaWqDX62EwGLBq1Sqnf/wDAwNRXl4OvV6P7u5u5OXlOe1Hbj+1Ws3+CFVVVaG8vBwWiwV///vfndYuRkZG4pVXXsG+ffsgFotx//33Y8+ePTh8+DACAwPZD83evXshFovx7LPP4tlnn4VYLMbevXv5w7ml0+mg1Wpx+PBh6PV6VFRUIC4uDsHBwXj77bdhsVhQUVExrxpXLnCvqqqCXq9HU1MT9Ho9q/Hz8fGBzWaDXq/H4cOHERER4RA0X7x4ET4+PkhJSbEb9e7T3NyMqqoq2Gw2NDU1oayszKE9Ly8P4eHhOHHiBGvjvtUmISEBMTExOHfuHPbv34+mpiaEh4dDIpHgiy++YGPan19cEBwUFMQyk3wJCQnATMb2ZiiVSgQFBc0KGtwFkDKZDBs2bEBcXBwsFgtaWloc2u1xGUCTyQSbzcZvdoq7EOAHVu6C7LS0NOj1evj5+aG7u5vfzJYfFBTExo+IiIC3t/ecWW5X+4ibzmUn7Xm6j5RKJSQSidNtuh3428Jlcn19faHX6xEaGsrKB7iANzQ0lGWTQ0NDnV4IzKcvH/9419XV4erVq0hNTUV2djb6+vpYpnl8fBzLli1jgY1CocCyZcvcXiy5O05k6UhMTMTIyAjy8/P5TXelOxLUOmOxWNht676+PlgsFly8eBEA3F6td3d3swd23PUjt5dGo4FYLEZfXx+/yaW2tjZUVVWhv78f4+PjMBqNaGhoQFdXF/tDrtFooFAoUFtbi4aGBjQ0NKC2tnbeGc6qqir8+Mc/ZudKaGgov8u8JScnAzPBKQB2/nLTbTYb+6Niv032fHx8IJVK+ZO/U+wzqgaDAR0dHazmtbm5Ga+++irOnDkDzNxum0tlZSX279+P5uZm3HfffcjKynJoz8vLg1KpRFtb201lcWUyGRISEjA5OYm2trZZba4yjPa3tH18fNjFz0JIS0uDTCZzepvYXRa2rq4O5eXlMBqNiI2NhVqt5ndBY2MjJicnkZ6eDr1eD5vNhunpaX43B+72kbuspqf7KDY2Fn19fU63aaE52xalUomNGzdiYmIC5eXluHbtGjIyMqBWq2EymdDc3Axvb29kZ2cjMzNzVt0qZz597Tk73tnZ2Vi5ciXq6+tRXl6O5cuXs/1XV1cHk8mEqKgo6PV6yGQy3LhxgzeqI3fHiSwNNTU1MJvNMBqN6OzsdJutne/zDa4SBnfaoglqCXEmODgYYrEY+fn57DZ+fn4+xGKx0zpDV7iSB26MlStX8rvMW2hoKMbHx2/6lz4XzH+XKZVK+Pr6uqy1VSqV2LFjBys9CAkJ4XdxqbW1FRaLBREREWxaXl4ekpKSZmV3PSWbeVIdgMOT5Zxly5ZhcnJy1nR7ppm6SZFIxLJtfFwGTTZTjuAO91Q7/0l42M0/ODjoMJ3PaDTCarU6vcDiAk3uZ2d0dBQAXB6zufaRWCx2GWRz3O0jtVo9rwf8boWrbeF+93Db0NLS4nCuGQwGfPTRRygvL8fx48cxPT3N6l355tMXLo63zEXts0gkYhcqp0+fZsewtbXVoSbYGU+OE1ncjEYjLl26hEuXLs35kN/XX3+NI0eOoLa2Fn19fZiYmGAXr9PT07Barejv70djYyOOHz+Ozz77jD/EokBBLVnUuMCvoqICer2efeb7sGBOTg7EYjH27dsHvV6Ps2fP8rvMW19f37yDa3tcwP5dZjAYMDEx4fJWdnx8PIRCIU6cOIH9+/fjypUr/C4uSSQSCIVC9ss8Ly8PCQkJOHfu3C0FtDabDSdOnJgVrGEmK2qz2Zy22bN/qMeeyUW5gavgIy0tDQqFAm1tbbMCWthljufKyvEffHLH1brDg33EBV/8mmFnXC1HKpVCLBYjOzsber0e/v7+8Pf3x4YNGyCbZx2qO3Nty3z4+vp6dF5gjr5zHW9PcT9vrs6L+RwnsjgEBQVh+fLlTj+eyM/PR2RkJNrb2/HnP/8Zr7zyCg4cOIDS0lIcOHAAL7/8Mt59911cuHABISEhKC4u5g+xKFBQSxZEQ0MDxsfHF+S2vr2GhgYYjUaHmmruAcH5lB9g5lZ/ZGQkNBoNy77cCq7sgCs34N5kwE33hM1mc3qr+ruku7ublRsolUpER0c7POAlEAhYTWd0dDR/diYvLw+/+tWvWL2sfd1sVlYWK2fgShnmi6t9dvUqN1dZUdlMnWh2djbgpD6Tb3BwkG0vVw/r7G6AWq2GQqGA0Wh0WXvqKnOclpaGjRs3siwovz7TXnZ2NruNrVarIZVKXdZZzrWPRCIRvLy8Zp3z89lH9hnH8vJyjIyMYGRk5JYDTz5328LtJ26/qdVq+Pn5sWOv0+nYtqSlpbmsWcY8+ro73qaZtx3wa5+5Y69Wq/Hwww9DqVRCNvN2Dnc1y66OE1m8NBoNtmzZgqysLPZ59NFHkZGRwe/qVEBAALRaLbZu3Yri4mL22bx5M5u2a9cuFBcXQ6vV8mdfNO5YUNvS0gKlUok333zT6S0vsvS0tLQ4HMvGxkaMj49j27Zt2LJli0Pf+XjuuecwPj6O3//+9ygvL4dMJsPbb7+NhoYG7Ny506MAt7q6GsPDw9i2bRv27NnDMn6RkZGoqqqCyWRCfn4+9u7d6/GY3MNwOp0O5eXlSEpKQnl5uccZ5OTkZNhsNqd/NL9LKisr0dPTgw0bNrA3I5w6dQqwKyHIyMjA5s2bWc12UFAQmpubMTIygqSkJBQWFjqMs2vXLsjlcnz11Vdobm5GREQEvLy8kJSUNOtNCp4SiURYtmwZyxDq9XqHwJDLdvKZZuomg4KCoNfrkZ6eDovFwuqt09LSHLKMdXV1sFgsSE9PR1RUlNM6WcxkLL28vFidJPfhAiS4eWtCXV0dhoaGWJ2sVCrF1atXYTAYWIDJvbKnra0NPj4+0Ov1iIuLw8DAgNMsoXLm9VTu9pGfnx+8vGb/2ZnvPvIUf1uUSiUefvhhdkvePmC3N9e2GAwGXL16FVKplO0Xo9HI9svly5fZtkRFRTkEovxtcdfX3lzH+/Tp0+y80ev18PHxYSUTLS0tMJvNSE9PZ/253zv8fQQ3x4ksXlwiYHBwkH0aGxsxNDTE7+pURUUFu6sVEBDAPgqFAgqFwuF5BrPZjIqKCru5F48l941iZPHS6XR44okn8Pbbb3sc2N0qjUaDoqIiHDp0aN6F7q7cjjGdOXjwIAYGBujdvYQQQuYtICAAmZmZOHHiBJRKpcv6+6tXryIzMxNGo9FlLXpmZiYuXbrkEMwCgL+/P0ZGRoCZYJYbg7tr4Myd/EYxuhQjC+ZOfKFASkoKRkZGFjT4vB1j8ul0OojFYqdfVEEIIYTMR3p6OjZt2oRNmzZh/fr17P/5b39xhSs9SExMBABcunQJZ8+eRUVFBc6ePYuzZ8+yYLa4uBhbt27lD7EoUKaWLCiNRoOSkhJUV1ez12eR2Q4ePIiWlpZ5vReXEEII4dhnaucyV6a2uLjYo1cm2tu/fz9/EnCHM7UU1BJCCCGELDEBAQHYunUrampq+E2zJCQkONTN8gUEBCAxMXHOh8DMZjM6Oztx9uxZl2NRUEsIIYQQQubFvv7VHa4e1hP2D4pxuADWkzEoqCWEEEIIIUvenQxq6UExQgghhBCy5FFQSwghhBBCljyX5QeEEEIIIYQsFZSpJYQQQgghSx4FtYQQQgghZMmjoJYQQgghhCx5FNQSQgghhJAlj4JaQgghhBCy5AkUCsUe/sRbER8fj61btyIwMBDt7e38ZrduZd47bfv27QgJCUF7eztyc3PxyCOPICMjA6tXr4ZAIEBnZycUCgUKCgogEonQ2dnJH4IQQgghhNwkytQugNzcXADAyZMnodVqERsbi/Pnz6O0tBRdXV1ITU1FfHw8jEYj2traEBcX59HX2hFCCCGEEM9QUHuLFAoF5HI5rly5AgCoqanBa6+9hpqaGgBAT08PACAoKIi1T01NIS4uzm4UQgghhBByK+YsP9BqtcjNzcXAwADMZjO/eRaZTIbo6GgMDAygvb0d27dvx+rVq5GRkYGsrCyH2/GYyXJyt+rDwsIgEAjYvFw5QlZWFjIyMiCRSBxu73P/5vrFx8ejsbERWq0Wer0emZmZbpdn3xYfH4/NmzdDKBTOqzQgISEBwcHBaGhocLp/7rvvPgiFQtTX17P2lStXQiqVorGxkd+dEEIIIYTchDmDWoVCgRUrViAxMRGJiYkwmUxOgzcOP6hNSUmBRCJBXV0djhw5gri4OISHh8NkMiEiIgKrVq1Ca2srDh8+jBUrVkAqleL69euw2WzIycmByWTCO++8g3vuuQeJiYnw9vbG559/DolEgtjYWIyOjmL16tWwWq147733EB8fD61Wi6+//hqHDx9GQEAAEhMTMTo6CplMhtTUVLYuAQEBiI2NhclkQnt7O7766qt5BbSYCVq9vb3xxRdfOEznAuugoCBcvnwZ9fX1rC0oKAhyuRzj4+Po7+93mI8QQgghhMzfvMoPJBIJNm/ejKeeempeNaHDw8PsdvzY2BibLpfLAYAFki0tLbBaraxNIBCgpaUFmLltPzo6ivDwcGCmfnV0dBT5+fmQSCT48ssv2XxWqxVtbW0AgLa2NlitVrYsgUCAmJgYNsZbb70Fo9GIm+Xn5+ewTZyamhq8/PLLOH/+POLj41ndLUcgELCSBEIIIYQQcmvmFdRybja45fP394fVamVB4djYGAtq/fz8IBKJkJ+fj5KSEpSUlEAqlcLPz4/Nf+XKFUxNTeHy5ctobW1lY3LrV1JSgs2bN0MikcDf3x+tra2orq6GRCJhY27fvp2NdzvU1NRgeHiYBeMAMDQ0hKmpKYd+hBBCCCHk5t1UUDs1NYXz58/fcpZzZGQEQqGQBap+fn4QCoXATIBrsVhQUVGB0tJS9nnvvfeAmbKIhIQECAQCxMbGIj4+no05OjqKo0ePOsx37NgxAEBraytee+01lJaW4vz58wgMDJyVRV1ICoUCQqHQIZsbFBQEgUDg0I8QQgghhNy8eQW1XDD78ssvs3KCW8GVHajVamCmdIALajs7OzE1NcXa4uPj8fOf/xwFBQUAgNWrVwMAjh49yupqufmEQiF7u4BWq8XTTz+N3NxcaLVa/PznP4dWqwVmMqb2meKbMTY25pA95i8jLi4OIpGIvQWBMzU1haGhIYdphBBCCCHk5nj0oFhoaChqa2tx9OjR/7+9/4ttI0vv/OFvMmIPih7LEQnJ0lDTY88QZDSkJtr0OJEuVOvl7sxcqIOxDXEZjwFjtt2IU0CEhfaiB1hnqJdE5iJ9EV6oAcYL29MwoHjZFGxnYQHJbCIYVBbSwNiGxqSiFcFue9viiC2BlC23Wdumgt97sXXOnipWFUlZtqTu5wMIsKsOq86f55zznOd56pyGH1KZfSgGgH/p/7u/+7uQJAkff/wxHjx4gLa2Nvh8PgwODuJrX/satre38fjxY/z617+GqqoIBAIYGhrCt7/9bTx58gTT09P40Y9+hK9//evIZrNYXl7G8+fP+d6v/+N//A+0tbWhv78fg4OD8Hg8KBaL+Lu/+zsUi0UcOXIEAwMD+IM/+AN8+9vfRqlUwj/+4z/uePeD3/md30FnZyffHcL4js7OTvyv//W/8E//9E/8N9/73vfwW7/1W7h7967uWQRBEARBEMTO+K3BwcH/z3iRaJ7e3l78m3/zb5DP55uyXvf29uLf/bt/h08++QSzs7PG2wRBEARBEMQOaCn8gKhndXUVxWKR76jQCI/Hg3/5l3/huzMQBEEQBEEQLw4ptbsAs7g2+uCst7cXPp8P+Xz+hT6wIwiCIAiCIPRQ+AFBEARBEARx4CFLLUEQBEEQBHHgIaWWIAiCIAiCOPCQUksQBEEQBEEceEipJQiCIAiCIA48pNQSBEEQBEEQBx5SagmCIAiCIIgDDym1BEEQBEEQxIGHlFqCIAiCIAjiwENKLUEQBEEQBHHgIaWWIAiCIAiCOPB8pbe39/9nvLhb/PjHP8bQ0BA+++wzlMtl4+2m6O3txZkzZ/DNb34Tv/M7v4ORkRG0tbWhWCwakxIEQRAEQRBfUl6apdbv9+O1117D8+fP4fF4dPd+9KMf4Sc/+Ql6e3sBTfn98Y9/rEuz2/zhH/4h/uRP/gR/+Id/aLxFEARBEARBHHBemlL7u7/7u3j+/Dk2Nzfx+uuvcwW2VVZXV/H+++/jb//2b423CIIgCIIgCAIA8FuDg4P/n/GiSG9vL/7dv/t3+NrXvma8hc8++wz/8A//gNXVVd119ptPPvkEz549w+/93u/h17/+NX71q18hFArhO9/5Dv89AP7sSqWCUqmE48ePAwBee+01fPLJJ+js7MTm5iZKpRJ+7/d+D+VyGT09PQCAR48e4W//9m/5Ozc3N7kCzKy///N//k/863/9r/Haa6/hX/7lX/Dhhx/iV7/6FX784x/D5XLxd//N3/wNoFl1f//3fx9f+cpXAAD//M//jNnZWUCzMh86dIinJQiCIAiCIPaehpba1dVVfPLJJ8bLAIBPPvmkTqEFAI/Hg6985SsoFov41a9+hc8++wzd3d0AgNnZWTx69IgrxO+//z4qlYpOqZQkCQ8ePEAymcSvf/1r3bO/8pWv4PDhw7h9+zbu3buHr3/96wiFQro0RlZWVvDrX/8az58/5wrtj370I7z22mu4ffs2bt++jddeew0/+tGP0Nvbi76+PqysrOC9997DvXv3cPz4cfj9fgDA3/7t35JCSxAEQRAEsc9oqNQCQD6f51ZVxmeffYZ8Pq+7xuju7oaqqlhZWQEAlEoldHR0NB2C8Pz5c9sPwZgy/atf/QpPnjzhCnOz9Pb2oqOjgz+HKe4dHR38WSxk4le/+hWuXr3Ky0IQBEEQBEHsP5pSas2stVZWWr/fj6NHj8LlcuHP/uzP8Gd/9mf4zne+g6997Wvw+XzG5C3zL//yL3j27Bn/v/jvZjl06BBee+01fOc739Hl8bXXXsPTp0/xD//wDwCAU6dO4c/+7M90H7URBEEQBEEQ+4+mlFoYrLV2VlqPx4Pnz5/j9u3beO+99/hfpVJp2aLaDIcOHTJeasizZ8/w/Plz/PM//7Muj//lv/wXrKys8I/T3nvvPfz3//7f8dprr+GNN94wPoYgCIIgCILYJzSt1IrWWisrLbTQg83Nzbr7pVIJX/va13hs6k75yle+gm9/+9uA9kHXkSNHUCqVsLq6iufPn/MwB7/fb/pxG7SyGHdl+PGPf4yf/OQnkGUZf/Inf8LjdJkC/PTpU8NTCIIgCIIgiP1CS4cv1Go1HDlyBPfv38fW1pbxNvx+P7797W/j448/rouJfe2113Ds2DFIkoRSqYTXX38dXq8Xn332GX77t38br7/+Or7zne+gra0NkiThf//v/41yuYz29nZ861vfwv/5P/8Hn332Gbq6uvD06VP823/7b+HxeFAsFvF3f/d3AACn08mf841vfANPnjzBb//2byObzeK3fuu38M1vfhPHjx/H1772Nfzd3/0dvvOd7+Bf/at/hT/4gz/AV77yFfzTP/0TPvzwQ7S1taG/vx+Dg4P43d/9XXz22Wf4b//tvwHa7gdvvPEGstmsrnwEQRAEQRDE3tFwSy+CIAiCIAiC2O80HX5AEARBEARBEPsVUmoJgiAIgiCIAw8ptQRBEARBEMSBh5RagiAIgiAI4sBDSi1BEARBEARx4CGlliAIgiAIgjjwkFJLEARBEARBHHhIqSUIgiAIgiAOPKTUEgRBEARBEAeePT9RLJFIoLe3l/9/dnYWyWQSABCNRtHf3y+krk8TDAYxNjaGYrGIeDxuTErsAXZtqigKhoaGcOXKFQQCAf7vTCYjPGFvaEbeXhayLOPtt9/G/Pz8S3+XoigIhULY3t7G7du3kUqljEkOFC9rDGBtIkkSAKBSqWBychK5XM6YlMPysri42LAdm00bDAbxp3/6p5ibm8Pg4CAAYHx83JjslZJIJJDP55FMJhGJRDA8PIy//uu/tq2bZnlZ7bnfaXUMkGUZ586dw9TUVNPjpzj+9vT0YGRkBDMzM3C5XPD5fHsuVwTxouyZpTYYDOLy5ctwOp2IxWIIh8OYnp6GLMtQFIWnq1Qq/H44HMbs7CxCoZAuDbE/aLZNXyaRSATXr19HJBIx3mqKF5W3RCKBRCJhvLyrvEgZg8EgBgYGkM1mcfbs2QOv0L4sgsEgzp07h0KhgHA4jFgsBgC4cOGCMSmHKWMul8t4q45W0p45cwbr6+sN20qWZVy/fp3LajQaxeXLlxEMBo1JX4hgMAiHw4FKpQIAcLlcqNVqu6LQvkxeRd98lfT09KBWq/F2eBFEowNBHGT2TKkdHh6GJEmYmprig2EqlcLy8jIGBgYsB+JkMolsNmubhtgbWm3TZDKJ8+fPN21l2Au+qPK2sbFhvHRgyeVyuHjx4q5a9YzPzOVyKBaLcDqdpnIQiURw6dIlAICqqsbbOlpJK8syPB4P7t69a7y1ZwQCAQDA0tISAMDn8yGfzxtS7Rxj3RPm+P1+rK+v73gxkUqlcP78eb5YWlhYQCAQMJVvgjgo7Fn4AVsx27k7otEoPB5PnctPdKFUKhVbV1U0GkVHR4fte4jdoZk2tQo/OH36NBwOBxwOB1wuF1RVxZ07d/Dmm29CkiSoqqoLUxBDHJgbfW1tjbuLRde6GFZg50JuRt4ymQwikQhOnTqFtrY2AMDq6irGx8d172HXmKufkc1mTeXU6HpMJBJwOp2QJElXnlbLqCgKTpw4AQBwOp14/vw5d6c3k0ejC94qPMiqXiORCHdxsslTlBOr5zNLZrVaRW9vL1ZXV3H16lWddZPl38xdLcoHS8eum9VrIysobOQDAN58800AwNbWVkMXcitpFUXRuYUTiYSun7D8Ly0t6ermN7/5Db7+9a8DWtuwvvT48WP09PRAkiRdmxll2tgOYoiEOKbKsoyf/OQn+Pu//3sAwMjICD755BP4/X5AkyUAXE6YbDG5MKaNx+O69rx58ybGxsbq8r2wsIAf/OAHaGtr05XDSp7M+qYI6+Nra2v41re+xX/r8/m4HLFnGdvAODaJdfn06VMAwMOHD037vdj3KpUKJEni8mBVFpiErtilNfYFt9tdF36QSqV0bdlMfyCI/cieWGqDwSCcTic2NzeNt5qCuVt6enqMt+qIx+N1Axix+7xomwKA2+3G7OwsYrEYVFXFm2++iStXrmBychIAcPLkSUCbCMQQh1KphMHBQWQyGczMzEBVVa6oKIoCr9eLyclJhMNhVKtVWxeyGaK8BYNBhEIhZDIZHl7hdrsRiUQQj8exurrKJ01ZlnHixAlMT0/zUAav1wtZlo2vMKW9vR0zMzO8jKFQCJVKpeUyHj58GPfu3cMf//Ef491330WlUkE2m22Yx6DBBT89PY2hoSFEIpGG72QsLS1BVVWuuMiyDLfbjXw+b/t8Bmvn8fFxnDlzBtVqlYcDOJ1OU3dpNBrlv5ucnITb7UY0GuX3zeq1kXVKlmV4vV4Ui8U6hRYA7ty5gzt37hgvm9JKWp/PV9enWD8R8w8AU1NTUFUVs7Oz+I//8T8im81yhe/BgwcAgNdffx0zMzO6cAozmT5x4gRkWeZWU1Hp7ujo4JbZnp4eVKtVbrV1OBw4dOgQlyWmSIbDYWSzWZ38OxwOdHZ2IhaLYXp6Gn19fabtCe09bCyQJAmDg4P4+c9/junpabS3t2N4eNhWnox90wxJkvDs2TOe11AohHw+j3A4jNXVVZ235ujRo1hcXEQ4HEa5XMa5c+cQDAZ5XS4vLyMcDuPevXs4fPiw8VWAJlNDQ0O8LYvFIldK7coCLeQDWv+yS6soCtxuNyYnJ3mfsSKTyeDJkye8rxLEQWRPlFqCMKNUKiGVSiGXy6FaraJcLiOTyaBSqejctMlkEhcvXkQul+PKtBU+nw+FQoFbURYWFnDkyJGmFUsjxkne5XLB4XAYkwHaJPHWW29xq0dnZ6cxiS2sPgDUKTYijcqoqipXOozY5TEQCECSJKysrAAGd2WjdzKY297j8SAYDCIQCEBVVczNzSEQCMDhcHDXeiqVQrlc1k2qRiWyu7sbkUikrh0YwWAQHo+H/y6TyaBQKPD3o4V6ZTClQVVV3Lx503j7pcFk2xgq0mr+RcQ+tri4CLfbje9+97sAwJW2VCqFt956yzQsSJZlOJ1OLk9GF3itVsPCwgKgLQZVVeXyYywHACwuLiKXyyGVSqFUKsHn8xmTAACXNfZM1r5ra2uo1WqAJq+N5MkOVVX5bzc2NnT9xljPlUoFc3NzgCb7kiQhEAjU9Zm5uTm+KDZiDOO4e/cuH+calSUQCKBarSKTydS909hP2TjK2rwRHR0dxksEcWDYE6WWKS077Txslbq2tma8RewRL9qmrRCJRHDjxg2k02lcunSJWzeMMKWgv78f6XQa6XQao6OjkCSpKSs/wyhviUSCP29oaIhPqkaC2odzLO2xY8eMSV6YFy2jXR6N5Wa0+s67d+/C4XAgEAigs7OTKyQulwuHDx/G2NgYf05vb6+lDMXjcSwvL2N0dBTpdBo3btyo+1jO5XJBkiRTBWonBDU3LwDTsIODhqicVSoVbG9vY3V1lXtDJiYmkE6nLT8wM36c1NHRseO6Nn7kZFQcW6VVeXoRqtUql4W1tTVsb28DNn3GjM7OTqiqyutAXLw3KktnZyevL6t3sn5q1uZWvGgbEMResydKLQDk83m43e46y46iKLh+/XrddRGfz6cbDIj9wYu0aSsMDg6iVCohHA7j7NmzKJfLxiSAoGhns1mEtd0M2G+YpasZRHmLRCJwu93cXT8zM2NMzmEfzjEX/b1794xJXpgXLaNdHln/Miqqrb6TuTX7+/vR1dXFLUqVSgVPnz7l72Z/Vu5haIotS8dc78ePH+f3mWLQqlXcDKbQVqtV7hk46IgKnsvl4jG0zPIdDoe5i//MmTPCL/8vomXWaLVtFRaTynhR5XMn8rRTnMIHgz09PbwerfqMGRsbG5AkidcBW5ChQVmCwWBdP4LJO80MDWKbm/GibUAQe82eKbVzc3NQVZXHIkGIMRLdmkYURUFvby93WxH7h5226U5gk0okEkF3d7fxNiefz+vi+KLRaEsKtpm8iZPx4OCgZfgBtLQsFndgYMB4e1d40TJa5dEsHpZtGdXqO/P5PPx+P2q1Gld8l5aWUKvVeKw0e74Y/ypi3JJpc3MT1WqVx4vCJNxBbhALaweLEb569arx1iuBKSW7oaAz2KKTtTVbEIpbgbGFgdECa1SmRBf4TmHhBqwfv8guCq3K04vQ3t7OwwcGBwd5qIKxzwwPD+sUdxG2GGD5ZWEE7J5VWYxhC8Z3GvspC9mBUN92kLWWOMjsmVLLLAPVapW7vMbGxjA/P6/7StTlcvH76XQasixjenq6LpbOimg0+oXam3A/02ybvigLCwtob2/HxMQEQqEQPvroI67ksgF+dHQUiqIgmUyiUChwN15fXx9mZmYsJ+JG8sZi/0KhENLpNEqlEmq1Gp+48vk8ent7cfnyZayurmJrawujo6O4dOkSPv74Y8DEotIqL1pGkbm5Ocs85nI5TE1Nwev18rYsFApIJpMtv5PlWVRazJ5fLpctZeXq1atwOp28bbxeL27dumVMhng8zmWw0TOtkLUP2ozywBR3WZZx7dq1uvAHM1pJaySfzzdtPctkMiiXywiFQohGo1hZWUF7ezveeecdHje7tbUFRVEwMTEBaHWa0T6wlGUZ6XQaExMTqFarSGq7H1y+fBmKosClxY8zN7foAt8JtVoNDocDaS18ZXl5uelx3YxG8iT2zT/6oz/i5doJW1tbGBkZQTqdhtvt5tsY5nI5zM7Ooq+vD+l0GoFAQOdRFOcjVu8s7YkTJ/huCXZlcRn2BTZLK/ZTMWTH4XBYhh/IsowjR47wRQtBHET2bEsvgiAIwh55B6dGmcFCKay2PnzVREy2ejsoNLN1IYPVe6NT4/YDiqJgYGDgCxE7Tnx52TNLLUEQBGFPJpNBsVjkbmhif2O0yg8PD6O9vf1AfP/h8/korI848JBSSxAEsY+5efMmurq6dhS+QLxaMpkMHj58yN39bP/f/W6NZmEY+92aTBCNoPADgiAIgiAI4sBDllqCIAiCIAjiwENKLUEQBEEQBHHg2fPwg0Qigd7eXv7/2dnZAxHXc5C/3n3Z2LVpJBLBqVOn6jYA397exu3bt23rspkviVkatsVWNpvdF197EwRBEATxctkzSy3b/9DpdCIWiyEcDmN6ehqyLO9478CXjXHzd0JPs21aq9X4iVzsz+o0KoZRWbWCbZgfi8UwOTkJr9e7b+WJIAiCIIjdY8+UWnY8J9u0GtrG9svLyxgYGOAnUu1XUqkUzp8/b6uIfdl4WW0aiURw6dIlAOBno5vBNg+fnZ1FLpdDJpPB+fPnLa26BEEQBEF8cdiz8INmN7CORqPo7+8HtOMb2cbQzP2/tbWFo0ePAgBWV1cxPj4ORVEwNDSEK1euIJPJ1G08LrrARbe33TPFfKyurmJhYUEXfiDLMt5++21+zCFzubN312o1uN1utLW1QVVVnjejO94q/EKWZfzkJz/B3//93+9bRbqZNt1J2Mabb74JaKf4vP3225ifnzetI2O7EwRBEATx5WFPLLXBYBBOp7PhEYuKosDr9WJychKxWAwQ3MvQzqyv1Wrczd3d3Q1FUfiZ2OyMbHam9srKCmRZxsjICDKZDMLhMDKZDEZGRiBrZ9ZbPTMej2N1dZUruSLBYBDnzp1DoVBAOBzG7OwsZFnW7SvZ3t6OZDKJWCwGVVVx+vRpBINBvo8he9+JEyd4XkQymQzeeuutphXBV02zbQqtjtk+juzPLkTgzp07uHPnjvGyKaqq4gc/+AF/7ss4950gCIIgiP3Hnii1zeLz+VAul5HJZJDL5bC4uAi3282VvlqthoWFBQDA2toaarUaIJyB7vP5AAB+vx/lchmpVAqBQACqqmJubg4AMDc3B1VVuQJs9Uw7RKUZ2jO3trbg9/t5mkKhwMtRrVaFX4O75lOpFN56660vvJXRLKbWzPK6E1wuF54/f84XCX19fbYKM0EQBEEQXwz2RKllil1HR4fxFqcVy58ZCwsLOHLkCGRZRkdHB/L5PACgs7MTLpcLExMTSKfTmJiYgMvlQmdnp/ERTcM+XlpbWzPesiWXy2FychIAeH4uX76849jTvaSZNm2GRCLBraw7qQtVVXH37l1Ai+ctlUp8cUMQBEEQxBeXPVFqASCfz+usrgxFUXD9+nW4XK4XUpKWlpZQq9UwNDQEp9PJQxI2NjZQqVT41/ns70W2fWLnevf09BhvNSSXy+HixYsIh8OYnJyEJEk4c+aMMdmBoFGbGq+bMT4+ztvk4sWLLZ1DXqlUsL29bby844URQRAEQRAHhz1Tapnb/9y5c9waJ8syhoaGuKteVJKCwSAGBgZ4OEIjcrkcisUivve976FYLPLfLC0tQZIkDA8PA9qHSzdu3HghF/XS0hJUVeXhBsPDw2hvb+fhCFbIsozr16/zd1cqFaiqio2NDWPSA0EzbfoyYQuZkydPAlrbut3uhu1AEARBEMTBZ8+UWmahrFar3PU+NjaG+fl5bjVNJpMoFAoYGxvDxMQEAODq1auGJ1mzsrICVVV1Sk0mk8HMzAxkWUY6ncbo6CiWl5ebiunM5/Po7e3F5cuX0dXVxa/ncjlMTU3B6/UinU7zj78afdRlzMvExASq1appXmRZxrVr13Qfn+03mmnT3UZRFB6mwMI5PB4Pb9v5+fmG7UAQBEEQxMFnz7b0IgiCIAiCIIjdYs8stQRBEARBEASxW5BSSxAEQRAEQRx4SKklCIIgCIIgDjyk1BIEQRAEQRAHHlJqCYIgCIIgiAPPnux+EAwGMTY2hmKxaLrVUyKRALSN+ImDgaIoCIVCxsuAdsrXlStXdmWfWlmW8fbbbwNA3TNZHiqVCiYnJ1s6uMEOJq+Li4u67dYSiQR6e3sBAKurq7byGo1G0d/fDwDIZrM6uRfrrtm6MutD4jsAYHZ21nR7ODRIy+pYkiTAJL8ikUgEp06dQltbG2BSD3blFutve3sbt2/fNt1+TVEUDA0NNVUvrRCNRuHxeHZVVvY7kUgEIyMjmJmZMa3rRkQiEfzwhz/E+++/z9uCySI7WdHYzkZZYzIeCARMxwyjDJmRSCSwublp+x47+UcD2WQoioKBgYGmZMQsbSt5Evud2Tgg9he75zCsxi0Ru74VjUbR19dX1y/Fcl64cKGuHRKJBNxut+6Zoty5XK66dxplyGw8sOuvxnpmWNWTsWys7svlcp3sGdMS+5sDa6k1HlxA7C3JZJKfBDY7OwtVVTE5OYlwOIzz58/XDZgvAjs1LBAI6K6/jONwjYMtIxqNwu128zKya2ZEIhF4vV5MT09jenoaXq+X7zcciUQgyzJmZ2cRDocxPz+vO7zCijNnzujypCgKvF4vz8/s7CxkWTbd19gubTAYxLlz51AoFBAOhzE9PY2+vj7TfibLMkZGRpDJZPiJeG63m9eDXbmj0SicTic/2W95eRkjIyOQDafOscM7voxEIhFcv35dV2c7OTp6tzAuYBgXLlwAAMRiMcRiMXg8Hp28dHR0IJvN8vGBjQfimMFkTVVVLCwsCE+vR1TuGHYybYadbDLsFupGzNK2mqfTp0+jXC4jHA6jXC7j9OnT/J6iKHy8mZ2dxdDQUF1fEbEat1qlra0Ng4ODxsuczc1NeDweLpPBYBAOhwMwjM9+vx+qqvKTPUVkWcY777yDYrHIZeH27ds4deqU5ZhqNv8bTwqdnZ1FKBSqG7uCwSC6urpQLpf5gUlsz3i3261rH1mW4fV6m9p3fj+TSCS4sfCLzr5UasfHx+tWSwQhsrW1pVNi2WD66aef6tK9CJFIBJcuXQI06xIjGAzC4/HoTklbWFhAV1eXqcIhDuipVEo3mPr9fmxtbWFubg7QTmWr1Wp1CruILMs4duyYLk/JZFK3eGCnq5lNanZp2QEazPKytLSEra0tdHZ2Gp7yfyeC8+fPc0tIJpNBuVzmR1vblTsej+uOQWYHpBiPmj558qTp0cfEzkilUjh//nzLE3Q0GsXo6ChKpZLuuizLcLvdWFxcRC6XQy6Xw+LiIu+bwWAQTqez4SmJwWAQoVAIhULBMm9MkTly5AiePn2qu2cn02bYySY0JUCW5abGE6u0reSJ1WM+nwe08eTIkSNccfX5fPw0TXZyo9UYYTVu7QRVVdHd3V2nGDJWVlbgcDh4mViePvnkE9343NHRgWKxWGdhhaDMi9beVCqFTCYDr9drq7zbkUwmkc1mMTAwoBuXh4eH4XA4UCgUdM9nchAKhXh6ljczay+xP9lTpfbQoUO4fv060uk0rl+/zoVLXFUoioJ0Oo10Oo0bN27orEmSJOlWYtFolKcVLRqKouDatWu4du0abty4gXfffVd3X7Y5rUsRTqwido6iKLo2NlqhoLU7a79Gq8pHjx7pBn02mD5+/FiXLqIdg2x8bjAYxOXLl/k7zd737NkzTE1NYWpqynjLFKfTaTphdXR0oFqt6gZ0pviZIU4S0Wi0Lm+nT5/G/fv3W5qwdirHgUAAkiTt6KjhVsttJBKJoKurC/fv39ddb1QWsc3ZmAGhzdl18VRA2IwfjYhEIrh27Rp/tpkCIMq28dlm75U1K7gkSTh16hTeffdd9Pf3w+VyYWxsDMFg0FK22XVm5WLlvnz5MsbGxni/E+vDqg8wHj16hFgsxpWuRjidTgSDQbhcLh7GYsfw8DAkScLdu3eNt3TcuXMHf/VXf4VarWa81RKNZDOfz+Ps2bNYX1/n16xoJa2IKMdsMVepVPj9trY29PT0IKgtDDY3N4Vfw3ShiSbGLVEWG3m3VFXFRx99ZGkZXltbA4TFqMvlQq1WQzabhcPhQDAY5Pk3W9gYlXkRZtU1Ku/Hjx83nf/N2NjYgCRJunHZ5/OhWCziww8/BAzPv3XrFiRJwvDwMCLaMevMc5BIJPDee+/xPiPOZ0Ydg405dnOaWb83wuZNsZ+K1mu20GP3zOoiGo2it7cXvb29SCQS/Jl/+Zd/qfudmFez5xwU9lSp7enpwZUrVxCLxaCqqs7dAq3BTpw4genpaYTDYWQyGe7imZqagqqqPGZGEVw9sVgMENxiAHD48GHcu3cPZ8+exZ07d+BwOLgwBwIB1Go1U9dIMpnUWZSIl4Pojo7FYnA6nZauJwBYX19HtVrlg6nf78f6+jqeP3/O0wQ16w9zj09PT9e5l9g7zTwDd+7cwZ07d4yXkcvlUK1Wdav8wcFBSJJUZ2lkiBOS+O+NjQ24XC4MDw8D2uTucrn4hBWPx3V5i0QicDgcfEC24uTJk4AwMdjJsTEtBEVodHQU5XLZ0nomEolE0N3drZugrMptZHBwsM49OTg4iKWlJXz++ee6tHZlYcoga/NMJsPDGs6cOQNobvJkMon29nb+u0bjRyMkSeLuU6NVR1EUXahFtVrleRHfy+5duHCBu0NVVcXt27fxzjvvIJvN8nhxAJaynUqlcPv2be5SZ++anJzUKV5nzpxBtVpFOBzmfc5qMvvFL35hWt+VSgWqqnJrWDAYxMDAAFckenp64HA4EAqFLCdM9hvR82FGJpPBBx98YLxsiplMG7GTTWMb2tFsWmOejHK8vb3NlcS1tbU6DwVTCtn4Y4XVuAVDGANr80b88pe/hKqqPP8imUwGT5484VZun8+HfD6vU0gDgQAcDodpW5gp8wwmW0bl/cGDB3XzvxXsuew9sizjyJEjWFlZQSaTQaFQ0Cn2mUwG8/PzfBwxeg6OHj2KxcVFHiIihoqJOkYqlbKd06z6vRni2DI7O4u+vj6+KDWGig0NDenmN2hzyOrqqi5WXZIkPHv2DOFwGNlsFqFQCPl8HuFwGKurq3XW7YPEniq1bBCz66RiTI9xEBAR3TPMBeZ2u7nSIU6YZh3RyjVCvHyCmjvf6MIUY7WMVKtVrK+vw+/3898bLQE5zZXOBj2Xy8XjvRg7bferV69CVVWMjY0hnU7j2bNnO7IeMRcZm/QDgYDpAA+tnoaHhzE3N2eZBtqA2d/fj/n5eVslATZpWd2xwdhoZTDCJoFSqWQ7yZgRjUbR3d2N2dlZ3hZM8Wn1WWyhKioO58+fR6VSgcfj4e3NJjRGo/GjEbVazdaaLS5cxsfHuavV5/PVhbGIHggrGsl2KpVCoVDA6Ogo+vr6dHUr0t3djUgkUve8ZsnlcpiamoIkSZiYmMClS5d0/ZBZyJhhwiyu9EW8AWZYyfResl/yZCbnjahUKpidnTWNO4a2IOjo6EBQCwGrVCrI5XI81IJZb+3GrFeF0YC1srJS19/m5uawtbUFVVVx8+ZN4df/ty5YqNjCwgIkSeJjjqhjNJrTxHZAg5BLVVW5B6NSqfB5xthvWgktEp+5sbGhy7txgXfQ2FOlthGZTAZXrlyB2+22NOFDiNtqpTHy+Tw8Hg9kWYbD4di1AZVoHeaiFK05oVCozm1kZGNjAx6PBydOnLC0BIgulaGhoR0pnmYwJSCsfZRQLBYBwR1nRHRtGl3w8XicP+eDDz6AJEl1Cjo0K26tVrMdtBTtg5VGFgw0mbYZBU+2+XLYrtyw+LI4GAwiEAg0/GDIjM7OTqiqWjeBMhkT65X9+/jx402PH0Z3n503gZFMJvlHK6K1ko1b/f39/Pro6KitxV+kkWzfvXsXqqpieXnZVGbi8TiWl5cxOjqKtCFUoxUyWmx1OBzG2bNn8fz5c94GyWSSW64gKAxi/KrL5aqz0htDK4zWXSvMZNrqWY1kc7cwy5MZLNwAmmXR+EEes1gyuWkVs3myUqnUWYTNEONNv/rVr+rusbjaEydOAMKCMp/Pw+fzobOz09J4wMZLs3HerM+2Cnvu2toa9wi4XC5MTEzw/nb48GGdFTqnGdmM4SnQjCnsmpk1nWE3p333u9+ta4edIJaN+H/sa6UWhgFzenraNGidCWErA9PS0hIcDgf/stpMISJeDczNNKvtAMD+Gu2awNrwjTfewJMnT+rSspgoZiWamZnR3d9NrJQpWKx8za6hgTvO5/Oht7cX6XQaExMTcLlc6O/v5ws9RVEgyzKmp6dtJ0+0mNaubEyhLRQKdQqtWRnFa9FoFF6vF8lkUqd0BQIBuN1urmyxyUBRlIZKl1kMHSxcmezfDx48aHr8EMejcDhsug2UGUnhS/9sNouhoSG4XC5Uq1XdzgBMMTRTQkWake3Tp09DkiTurjRDXFCVSiWEhI9kdopZvKoRUVHx+Xx16VOpFM6ePcvz1khGYSPTZs9qJJu7hVWejJgpSCwcgc1vRlpV9szmSZfLVac8W8HiTb/5zW/qri9pH8B1dXWhVqvxdqxUKnA4HOjo6LA0GmW0j0vNYnuNXped4PP5+NjFwiCYy1/sj3ZeQRGnFisOi4UHw25O+5u/+Zu6dtgJbDxuZgH8ZWJfK7URw8dEa2trlpNrPp/n1iS2IhPN+0YyWgjC9773PV1HJF4ObIBjA5Xf7+fu0lwuh2KxqIvjSSQSlsHzDNaGR48eNf3QAIaPrgYHB+vCD3aK+AFXJBJBX18fdzUZWVlZ4fGOTBlhg3xE+8iIyW0oFLKMYR0fH+eDYywWQ6VSQTabxfj4OCLa1mCZJraesUsb1GJpmQVS1ra0MbO0BLWYLuOXywy7ciuKgr6+PszMzNT1UaMSMqttEWdUfs0QY/kgjCGBQADFYpHHQQc19yCj1fGjFaKGrbiYu69SqSCfz+tis6PRqO4DFDvsZFsRYieXl5dNldWEYZufzc3NOuWyGRKJhC5WsLu7m1vZjWU/c+YMJEnSuWmdTqdl/20WO5k2w042d4tW8sTGMhZqNzg4qFuoi3LCPqrbibKXz+d5yAla3AYxo8WbGrdTy+VyeP78Ob7xjW/o2pHlz+l02loTb926BbewFSCEumsUZ22Hoijo7e3l47Lf7zc1fqysrOjCCOxob2/n6cy+A2A0mtPE8QYm/aQZlpaWoKoq93rIJtucfRnZ10ptKpXC/Pw8t9iMjY3h4cOHSGnbfTB3SDQaRTKZRKFQwNjYGCYmJgAt7tEO1gHtBlSlwZfWRHOkUiluCUqn0zh06BBU4ev9eDyOarXK3UJutxtTU1MNJ9h8Pm85sBjfWSqVLLfUaZWbN2/C6XRyF9by8rKlJSYlxDeOjo7qPj5IpVJ4+PChpdyKyrMdfr8fbW1tOndXWnCPi3JslzanxUh6vV7e56yU1kAggPb2dm49Zn/sPXbl9vl8aGtr432b/TUzINv1yYz2gZUsy7xt5ufnkUqlEI/HUS6XeV2L1q+djB/NYpRtWduXOJfL6d6bTqd1ij6btEZHR6EoClZWVtDe3o533nkHa2trlrKtaO5uFr/J4gKNH6JcvXqVy3A6nYbX68WtW7eABnVs5NatW1xeQtrHa6yd4/E4isUiL7txIcPctC+KnUybYSebjXgZfRKCcpfWxj/WFtDkk8mu2LZosHuPkWQyqQs5cTgcdRZiO6zi+R8+fAi32627l9PiaqvVap0iKZLJZPDuu+/C4/HwOjp16hRu375tOu5AsPCy+R+aLDE5S2v9jFnI2SLWbK5n/cxuP17G1tYWRkZGeBvZzVHGfi+mN/Z7r9fLd6u4fPlyU+Og2VhdKBRM56F8Po/e3l5cvnz5hS3E+509OVFsvxAxOR2HIAjiy04wGMQf//Ef47/+1/9qOWl/WZFlGd///vfxs5/9zHhrz/jpT3/KDT7Ey4EtZIxhVsT+Yl9bal82Vu4IgiCILzOBQABPnz4lhdaEQCCA3/zmN8bLe0YwGMThw4dNvVUE8WXjS2mpDWpHCEqSZHrmNUEQBEEQBIMstQeDL6VSSxAEQRAEQXyx+FKHHxAEQRAEQRBfDEipJQiCIAiCIA48pNQSBEEQBEEQBx5SagmCIAiCIIgDDym1BEEQBEEQxIGHdj8gdgW2Tdrjx4/R09MDSZJQqVQwOTlZt9clS1ur1eB2u9HW1gZVVXXbq0WjUfT39wPaEbtmzyEIgiAIgmCQpZbYVV5//XXMzMwgFosBJkdzirS3tyOZTCIWi0FVVZw+fRrQjo/0er2YnJxEOBxGtVq1fQ5BEARBEAQptcSuUiqVkEqlkMvlsLi4CLfbDVmWjckAAIVCAZlMBrlcDtVqlV/3+Xwol8vcajs+Pk4bXhMEQRAEYQsptcSusrm5yf9dqVSwvb2tu9+IYDAIp9Opew5BEARBEEQjSKkldpWOjg7+b5fLhba2Nt39RjCrrfgcgiAIgiCIRpBSS+wqLNwgGAxiYGBAF0bQLPl8Xhe2EI1GcfnyZQSDQWNSgiAIgiAIgJRaYrfZ2tqCoiiYmJgAAFy9ehXQPv5qVjFNJpMoFAoYGxtDOp2G1+vF1NQU7X5AEARBEIQltKUXsSuwbbqKxSLi8bjxNkEQBEEQxEuFLLUEQRAEQRDEgYeUWoIgCIIgCOLAQ+EHBEEQBEEQxIGHLLUEQRAEQRDEgYeUWoIgCIIgCOLAQ0otQRAEQRAEceChmFpiV1AUBaFQyHgZAKCqKq5cudLyIQxmyLKMt99+GwDqnsnyUKlUMDk5uWv72rLtyhYXF5FMJvn1RCKB3t5eAMDq6irGx8eFX+mJRqPo7+8HAGSzWd22Z2LdNVtXZluoie8AgNnZWV1+zYhEIvjhD3+I999/n7+TPdvlcgEm+RWJRCI4deoUPznOWA925Rbrb3t7G7dv30YqleL3GYqiYGhoqKl6aYVoNAqPx7OrsrKbiOUOBAIvpQ7sSCQScLvdde+MRqPo6OjAwsJCnewweVheXq5ra2j7VhvlFkK/liQJMOkH7P78/LypTIuyxLCSKfascrnMZZX1QWOfYX0BwK7LSTQaRV9fX10eFUXBwMAAJicnceHCBWxubtbVpbFdIpEIRkZGMDMzA5fLVScrxj5tVjd2/cE4tjCM9cUwls2szq3SEsSLQJZaYldIJpMIh8MIh8OYnZ2FqqqYnJxEOBzG+fPnd3Ui3t7eBgAEAgHddZ/Pp/v/bmCcDBjRaBRut5uXkV0zIxKJwOv1Ynp6GtPT0/B6vYhEIvyeLMuYnZ1FOBzG/Pw8zp071/CQijNnzujypCgKvF4vz8/s7CxkWebvMcOokDIuXLgAAIjFYojFYvB4PFAURZcGmnIwMjKCTCaDcDiMyclJuN1uXg925Y5Go3A6nYjFYgiHw1heXsbIyAg/RU58x9DQkO7al51XecKeJEk4efKk8TIAYG1tDW1tbbp+6HK5UKvV0NXVxfMnyzLcbjfy+bzw6/9HJBKBoiiYn5/nY8j8/DzGxsZM5Q4WdbC6usp/z2Tq1KlTdX0gEAhAVVU4nU4ub8lkEtlsFgMDA7pnDg8PQ5Kkl3b4S1tbGwYHB42XOZubm/B4PDxPwWAQDocDMIx/fr8fqqpiaWmJX2PIsox33nkHxWKR183t27dx6tQpyzFLlmVcv35dV/+VSoX3VzbGhEKhujYKBoPo6upCuVyG3+8HAGQyGczMzMDtduvaQ5ZleL1eZDIZUmiJXYGUWuJAsrW1pVNi2WD/6aef6tK9CJFIBJcuXQI0yxEjGAzC4/GgUChwZX1hYUE3kYuIE04qldIN9n6/H1tbW5ibmwMAzM3NoVar1SnsIrIs49ixY7o8JZNJ3eJhaWkJtVqtThlnRKNRjI6OolQq6a4zBWRxcRG5XA65XA6Li4umC4ZMJoPz589zS00mk0G5XEZHRwfQoNzxeBwXL17kisLKygoAoKenhz8fAE6ePMkXMV9mjO37qlBVVbcYEWHt3dnZya/5fD4sLS3B6XRyGe7p6cH29rapwhUMBhEKhbC8vKyz+Fkpma0Qj8dRKpV0SmNQO757eXkZ0OSLcffuXUiShDNnzgDCgmp+fv6l1buqquju7q5TDBkrKytwOBy8H7M6/eSTT3R9sqOjA8Vi0VTxPn36NMrlss7am0qlkMlk4PV66xaSzWLVRsPDw3A4HCgUCrrnszEgFArx9CxvZtZegtgJpNQSrwRFUXD9+nU+wEUiEVy/fl03WSYSCaTTaaTTae6utOLRo0c4cuQIfx4b7B8/fqxLF4lEcOPGjbrnBoNBXL58mb/T7H3Pnj3D1NQUpqamjLdMcTqdpkpkR0cHqtWqbsJhip8Z4iQWjUbr8nb69Gncv39fp9Q2wnhM8aNHjxCLxSytZ0acTmfLykWr5TYSiUTQ1dWF+/fv664by2JEbPMbN25wGWNtzq53dXXpfheNRrmc2D3fSCQSwbVr1/izzRQUUbbFZycSCbz33nv8t2IfEWH9JxaLob+/Hy6XC2NjY/jP//k/637DysgscIqi8Pem02mdFb1RngGgXC7XKSIim5ubvE2D2sLy4cOHePLkCZdhZr2tVCqGX//ffitJEl/UiKysrECSpLoFnqIoujowyxdjc3NTJ7uBQAAOhwMffvghisWizgqayWQwPz/PFbGTJ09CVVW+4GSwseu9996rG1cYzcqSqqr46KOPMDQ0ZNrua2trgLDYY3WZzWbhcDgQDAYRDAbhdDqxsbFh+LW9lZwtMoz1e/z4cZw7dw6SJJlaYkU2NjYgSZJu3PP5fCgWi/jwww8Bw/Nv3boFSZIwPDyMSCQCt9uNhYUFfp8gXhRSaol9geiOjsVicDqdlq4xAFhfX0e1WuWDvd/vx/r6Op4/f87TBDUrEHOPT09P17m/2DuNcV4AcOfOHdy5c8d4GblcDtVqVWeFGBwchCRJdZZGxubmpum/NzY24HK5MDw8DGhWDpfLxa1f8Xhcl7dIJMInZTuYBYpNXMlkUmcZ/cUvfmFq1alUKlBVlVtfgpplyzhxmRGJRNDd3a2bQK3KbWRwcLDOfTo4OIilpSV8/vnnurTGsojIhpCITCbDwxqYBS4WiyGZTKK9vZ3/TgzfiMVigBCG0QySJHH3rtHqpCiKLtSiWq3yvADA0aNHsbi4iHA4jHK5bBt+8o//+I/IZrM8bvyf/umfAEFxEJVEWZZx4sQJTE9Pc3exKLN2eRYRFREjKysrfHHJ8rC0tIR8Ps8tiUzJMWsvJlNMeRNh14xyxyyEzcTOG5Uuv9+PJ0+eIJPJ4O7du3A4HDqlK5lMolwu4+2334bX68Xs7Kzp8x0OB2q1Gh9XRGurKEusve1k6Ze//CVUVTUN88hkMnjy5An3cPh8PuTzeZ1CyhR1M0s4G4/MFhSsr4uWdgB48OABpqamoKqqZcwsgz2XvUeWZRw5cgQrKyvIZDIoFAo6izJbOLB+WigUKOyA2FVIqSX2nKDmzje6vEUripFqtYr19XX4/X7+e6OlIpfL4eLFi3xQdrlcPB6NYTXZNuLq1atQVRVjY2NIp9N49uwZarWaMVlD2AQdCoWQTqcRCARMJyBo9TQ8PIy5uTnLNBAsWTtxm+ZyOUxNTUGSJExMTODSpUt19WoGm6RKpZLtJGhGNBpFd3e3ToFgCkKrzxIVKwhu+0qlAo/Hw9ubTbgMn8+HcrmMTCbD5c/tdptaz8yo1Wqm1kaGuHAZHx/XuYIrlQq3Bi4sLJhaJ61gIQBMcfD7/SiXy9y9/NZbb3Glwai8NMozgykiZtZE0ZLIrIi5XA6VSgUOhwOyLFtaEV81bJxgiy6jwshYWFjg7nMrhatWq3EL49ramq7vi7IErb3NFs2MSqXCFxxmYR7MGs4s4ZVKBblcjocX2VnCXzWBQAC1Wo33P3HRw5ibm8PW1hZUVcXNmzeFXxPEi0NKLbHnuFwu7upiLrtQKNTQOrixsQGPx4MTJ05YWipEt+/Q0NCOFE8zmMLMPpooFouAhcUJBre70QUfj8f5cz744ANIkmSqBAwPD6NWq1lOtLD5irsVMlqsbDgcxtmzZ/H8+XOoqmo5aco2XzbblRsWXz4Hg0EEAoEduSU7OztN88pkTKxX9u/jx4/D6XTaWpIZsvYBjdGdb0cymeQf1bDfiS5dMURjbW2t5RjihYUFrjh0dHRwpS0ohFuk02kcO3bM+NOmmZubg6qqOH36tO46UwxdLhe3IsLEtW3WN2Fi6ROxszI2iygPzAsitkNvb29dXClTUs36YCNYKEAzsiQixpt+9atf1d1jcbUnTpwAhLpk1vDOzk7LxbmVtZtdM/aJVhEt7cyr43K5MDExgXQ6jdHRURw+fFhnhc5pni5jaBJB7Aak1BJ7DnODsR0A2F+jD2OWlpbgcDjwxhtvcJeiCIvZYu7XmZkZ3f3dxEqZgoXb3ewaGkzkPp8Pvb29SKfTmJiYgMvlQn9/P4/nUxQFsixjenp6xwqtGWaxsQym0BYKhTqF1qyM4rVoNAqv14tkMqlT1AOBANxuN0ZHR3ULHEVRTC1ZIkZ3M4PJmGitZP9+8OABqtWqqdJtRFT4w+Gw5VZnRpLC7iDZbFZn9RRjPnt6eup2o2jEkvZR4NDQEJxOJ1d62Jf7zA1+794940+bJpfLYXZ2Fm63uy4WOZ/Pw+PxcCsiS1+r1eDxePD48eO6vslYWlqCqqp11lI0+KK/GZhllsmuz+dDNpvVjTGTk5OASVzpTmEKWzOyZISFeXzzm9/UXWft29XVxS3h0GTa4XCgo6PD0uJutOSLNFpwNIPP5+PjHguDYPImyrud140gdhNSaolXAhuA2UDq9/t5KEAul0OxWNR9RZtIJGw/sIBgJTp69KjphxAwfHQ1ODhYF36wU8QPuCKRCPr6+nj4hJGVlRUey8sUbTYJsQ92ZFlGUIsBZu5jI+Pj43yiiMViqFQqyGazGB8fR0TbGiyzC1vjJBIJ3YdG3d3dplbTYDCIc+fO1X1ZzbArt6Io6Ovrw8zMTJ3Ck0qlcPbsWV5WtkWcUfk1w2ghZB/1BAIBFItFbpVjCg8jn8/zcANmcRJdyC+CcfupjY0N3QKovb2d59cstrgRrP9873vfQ7FY1OXZ4XCgp6eHl+lFSKVSKBQKOHr0qO56pVLB7/zO7+jcztDq9Otf/zqePXumSy/ClOW+vj6d9ZqF0Fj1qWY4c+YM2tvbsbCwAFmI9RSxU/p2iihLMGl/K1iYh3G/3Vwuh+fPn+Mb3/iGbpxjde10Oi09RNCUZbew1R60fiHLsm4Hl1ZRFAW9vb28jcR4ZRGrD/4I4mVASi3xSkilUiiVStz1d+jQIajC1/vxeBzVapW7rdxud1N7Q+bzeUslwPjOUqnE49BelJs3b8LpdHIXm3FLIhGmDIyOjmJ0dFQXq5dKpfDw4UOMjY1hYmIC0OJ1GWa7H5jh9/vR1tamc62K7nGlwY4BIrdu3YLX6+VWUitFORAIoL29nVuP2R97j125fT4f2trauDWW/YmKjRV2Zclo+2HKsszbZn5+HqlUCvF4HOVymdd1tVrlv0smkygUCpbt8CIYZVvW9iVmsr21tYWRkZGm5X5lZQXt7e145513uOK0srICVVV1ShuLXRwdHcWlS5fw8ccfAxau/ma5e/eurt9C8JhAU8AYlUoFbW1tdYqkkVQqhWQyiaGhIS4HQ0NDmJyctOxTZnVglEPRC2CM9RTJ5/Po7u629QLYyZwRUZZYPhq1KcMqXv7hw4dwu926e8waXq1W6xRJkUwmg3fffRcej4fXzalTp3D79m3TxSgEZT8UCvExRAwrYHLMvEJskWhmXGDWeLv9eAlit6ATxQiCIPYItmAxhm4QBEEQrUOWWoIgCIIgCOLAQ0otQRAEQRAEceCh8AOCIAiCIAjiwEOWWoIgCIIgCOLAQ0otQRAEQRAEceCh8ANiV2AnWZmhqiquXLliu+1Ms7DN/gHUPZPlodLEmfCtEAwGMTY2hsXFRd0WQ4lEgu8pubq6avsFezQaRX9/PwAgm83qttIR667ZumJ5KhaL/FniOwA0dapYJBLBD3/4Q7z//vum71QUBUNDQ5Z5ikQiOHXqFD8wwFgPduUW6297e1t3qphIozzslGg0Co/Hs2uyEolEMDIygpmZGdNyfJFh8si2yzO2NSORSGBzc9P03heNRn1jt2HvW15e1tWvLMv4yU9+gr//+7+Hy+XCwMCATubZ+COOF+L4cvfuXbz99tuYn5/XjSfG8cbY5nb91lg3DKs6MpaN5Q9AXf81Kw/x5YEstcSuIJ6YxDbLZyfLNDoZrFXYMaLGzbx3cwN1hnGyZkSjUbjdbl5Gds2MSCQCr9eL6elpTE9P6854Z5ugs9PU5ufnce7cuYb7YZ45c0aXJ0VR4PV6eX5mZ2chy7Lt3ptWEwtDlmUMDQ0ZL3NkWcbIyAgymQw/nUnc5N2u3NFoFE6nE7FYDOFwGMvLyxgZGeF7jorvsMsDsT+4cOECACAWi2FychJer7duz2FxEbOfaPZwhFZo1DdeJsZjf0UqlUrdQQidnZ14+vSpbvwMBAKQJMlyj+FEIgGPx8P7bywWg8fjsa3HRCKh23O7Vqvx0x7FOjLbl9vv96NcLqOrqwvBYBC5XA5TU1OQJAnDw8M8XVA7ZCSbzZJC+yWFlFriQLK1taUbhIPBIBwOBz799FNduhchEong0qVLgGZBZbCNxsXTeBYWFviAa0Q87jOlnfHOjgX1+/3Y2trC3NwcoG2+XqvV6hR2EVmWcezYMV2eksmkbvHAjtY0KuOMaDSK0dFRlEol4y3OyZMn+QLCjIx2ZCybPNiG7eyIULtyx+NxXLx4kVtY2ORpPBigUR6IvUfWTutiB0oY5UKWZVy/fh1HjhzB06dPjT//QmKsA2PfeFnUajUAwOnTp423AOEgBDYuBINBdHV1YWVlBUeOHOHKsMvlsjzURlGUukNCrJTMVshoB6ewUwgZbLxbWlpCe3s7f34mk0GhUNAdOX3mzBlAOxyH+HJCSi3xSlAUBdevX+eDT0Q7vlQcvBKJBD+txmy1LvLo0SPdIMyUwMePH+vSRSIR3Lhxo+65wWAQly9f5u80e9+zZ88wNTWFqakp4y1TnE6nqRLZ0dHBz58Xr1khHu1rdqLY6dOncf/+/bqTnewwnoj06NEjxGIx0xOAoNVbV1cX7t+/b7zVNK2W24hVHoxlMSK2+Y0bN7iMsTZn17u6unS/i0ajXE7sno8Gafv7++vkDcLRz9evX6/LG7Rysd+lhdPgWF/5i7/4C909MQ+iBZApkeye0WIKoS7E3xn7qNgfxbwqioJr167h2rVruHHjBt588020tbXZHtV6584d/NVf/RVXusxgefrLv/xLnn+xbo3vjWheDruyNhpTFO04XpfLhbGxMfzRH/2RaR7+w3/4D1ymWJ6s2qVVWLnfe+89/g6xHdBA3owsLS2hu7u7ri6gKZ/VahWdnZ2Aprw6HA4sLS2hWq3yRWVnZ2dd32X4fD7TI6SZ4m7mMYtGo+jt7UVvb69pOzCYDInjKDsNbm5uru75N2/ehKqqOHnyJGRZhtfrNT1amck26//GtmokR8TBgZRaYl8guqNjsRicTqftBLG+vq4bhP1+P9bX1/H8+XOeJhgM8mNew+Ewpqen66wA7J1mcVx37tzBnTt3jJf5xCC6+QYHByFJUp2lkbG5uWn6742NDbhcLm59GB4ehsvl4pNOPB7X5S0SicDhcODDDz/k18w4efIkIJwPn0wmdZbRX/ziF3UDv8jg4CCWlpbw+eefG29ZEolE0N3drVOUrcptZHBwsM4yZJUHY1lEZIPbN5PJ8LAGZsWJxWJIJpNob2/nvxPDN2KxGCC41I2IacPhMKrVKk/rcDhw6NAhLm9G5aK9vR0zMzMIh8P8COdgMAhZlnHixAnujp2dndXJl/jc2dlZHssYDoeRzWZ52mAwiHPnzqFQKPA8DA0N6WQemgwXi0V4PB6uIInKiqIouvCQUqmkO+b08OHDuHfvHs6ePYsHDx5AVVX84Ac/MFUYMpkMPvjgA/7/Rrz++uuYmZkxbQfxvUtLS7ZlbWZMSSaTyGazPA7/wYMHgOYxuHLlCiYnJyFJEgYHB/Hzn/8c09PTOmuhw+FAZ2cnYrEYpqen0dfXZ6oQmfUNI+3t7Ugmk4jFYlBVlVtb7eTNjIcPH2J5eRkDAwOmym8+n+ftHggEUK1WcefOHayvr8Pv9yNoc+RtMBiE0+m07Mubm5twOp11743H41hdXbWMmWVUKhWoqsrHP2hyWSwWkcvlsLCwoDNm5HI53lfefvttlMtly7ADSZJQLBZ5H+rr60MkEmm6zxAHA1JqiT2HDaJshZ3L5bC4uKibcI1Uq9W6QXhjY0OXJpfL4eLFi3yQY1YJETZYtsrVq1ehqio/3/3Zs2e2Vigr2KQaCoWQTqcRCARMz36HVk/Dw8OW58MzmPVpfn6+zprSDGxStpoczGDKZKlUaul30JSP7u5u7r7GDvMAwWIvKvPnz59HpVKBx+Ph7c1clwxRoWPy53a7ddYys7TQjrhlE3WtVsPCwgKgWZ2MMlEqlfhHZKJikMlk8NZbb/F74qQOw3PZxM9CNkS5DwQCcDgcuHv3LgDUhX2IrKys8PhKWQshYO8QFw5MkRExLkBcLheeP3/OlQIr5a4ZWB2ZtYP4XruysjGBtTcbC5r9QI2FFrG6Zs8xa1M2bqVSKZRKpTpLZbN9g70zpy2aGXbyZgVzv7OFnEilUuHeoM7OTi6HGxsb6Ojo4OOk3RjzqmByyWSdhVWJ4Vms3QHg1q1b/LoRVVW5rFQqFd6OxvjhVCqF8+fPf+k+9vyiQEotsee4XC5IksQVu3Q6jVAoBEmSTN35jI2NDXg8Hpw4cYK70IyI7sehoaG6CWmnsEkyrH3kUCwWAcF9ZkR0uxtd8PF4nD/ngw8+gCRJdQo6NCturVazHWyVF/zyl1lvmHLTDLK2I0W5XK6bbO3KDU2h7evr0+18sJM8MDo7O6Gqat2EzGRMrFf27+PHj9tan0QaWap2SlAIjUin0zh27JgxSVO4XC4cPnyYL7bS6TR6e3tN615UAnt6elCtVnkfEkM4Ll26BEmSjD/XISoMVspds4h1W6lULGOq7cpq1t4vg1qtppM1o1zY9Y1m2Km8sQVBX19fXXw+CzX49re/zeNp2XWn08mtt2bjKVO4zeQJFiFHrWBst5MnT+Lw4cMYHR1FOp3GxMQEXNoODqLBY3Nz07TfNwObY6zGbuJgQUotsecwawjbAYD9Ndo1YWlpCQ6HA2+88QaePHlSlzYSicDtdnOX7szMjO7+bmKlTMFkorO6BuFDKbPn+Hw+9Pb26gb3/v5+HqOmKApkWcb09PSOFFpoVgu3280nEba4UBTF1B3HJu1CoVA3aZuVUbwWjUbh9XqRTCZ1inqreRDZ2NgwXQyZuTXZvx88eGA7UYs0mtR3yvDwMCRJ4i7me/fuGZM0RaVSwdOnT/lz2J+xbRjMFd3f34/19XWujAwODqJUKiEcDuPs2bPcEmaGleJp1v7NINaty+Wy3J3Drqxm7f0yEOPfYci7Xd9olheRt2QyiVKphIGBAd31XC6H9fV1dHV1weFwcGWOWS89Ho9OFozk83lTL4Ysy3C73aZhC83CrO+VSoVb243zwvT0NPcw7AZsrLUKHSMOFqTUEq+EiubyYgOR3+/noQA5Lb5PXH2zj2qswg+guWyfPHmCo0ePWg6k4qQzODhYF36wU6LCB1yRSAR9fX2mHyhAc/OyWF6maDPrSCQSwbVr13g8ZCgUQrlcNrXGjo+P84E9FouhUqkgm81ifHwcEe2jmUwmY/rbZkmlUjh79ix/D9uezah4QrMinTt3DuVy2dSta1duRVHQ19eHmZmZusVIK3kwIrqmIXxkFQgEUCwWdbGnHo+H/06cqIPatkCiy1fEOKlHtS2hjB+etYrD4UBPTw9//05g7lkWUy1rH8AYY0kZS0tLkCQJr7/+Ore0MlhsJIsHtcL4TmNbt0qz7WB8r1hWNqaIIUwJw5ZSuwWzSLN6yufzDftGK1jJm93YyLh16xYkSaqztG9sbOAb3/gGHj9+zOuWKbtf//rXbS3cyWQS5XJZt/UgK6+qqnwnl1aRte37WPgJU3CNFuMlbQcHs5CanWB8HpOjnYbPEHsLKbXEK4G5JFmIwaFDh6AKX+/H43FUq1VMTEwgnU7Dbdgyxop8Pq+LsxMxvrNUKqFms81VK9y8eRNOpxPpdBqjo6NYXl62tI6mUikUCgWMjo5idHQUhUKBK2epVAoPHz7E2NgYJiYmAC1elyEqz3b4/X60tbXpQjjSwgc7SoMdA3ZCIBBAe3s7tx6zP/Yeu3L7fD60tbVxayz7a2YisStLRtsWSJZl3jbz8/NIpVKIx+Mol8u8rsW4xWQyiUKhYNkOImLadDoNr9eLqakprK+vG5M2zdzcHLa2tjA6OopLly7h448/BnZgPcppWyt5vV6k02mMjY3pFCujPGW0L9aNiuPCwgLa29sxMTGBUCiEjz76yPQDIGjvnJychMfjqavzRsiyjGvXruks8FtbW1AUpWE7NCqrcUxxOp2mz1pZWUF7ezveeecdfPe73zXetqVWq8HhcNSNA436hlm5rbCSt0ZjI4Rtr4wsadtjPXv2THd9Y2MDbW1tpuOpyPj4OIrFIq/biYkJFItFyw84oY3Vvb29fAHocDh0/X9sbExn1fb7/aYeOLZgsduPFyayboWZHBUKBcvxnNjf0IliBEEQXxJkWcb3v/99/OxnPzPe2jN++tOf4uHDh1haWuKnWL2odfNVEPkSnyBHEPsVstQSBEF8SQgEAvjNb35jvLxnBINBHD58uKFlkCAIohlIqSUIgviSkEwm95VbNZfL4c///M8tXdYEQRCtQOEHBEEQBEEQxIGHLLUEQRAEQRDEgYeUWoIgCIIgCOLAQ+EHxK7ATrIyQ1VVXLlypW5rlp0gaxuaA6h7JstDRTvHfbfi9ILBIMbGxrC4uKiLR0wkEujt7QWAhmeaR6NR9Pf3AwCy2azu626x7pqtK5Yn8Utx8R0AmjpVLBKJ4Ic//CHef/993TutyiwSiURw6tQpvjm+sQ7sytxsXhVFwdDQUFN10grRaBQej2fX5MSsPb5sWMnSTuS7FWgXghdDHMe2t7d1p/sRxEGDLLXErpBMJus2y2cn/TQ6GaxV2OlFxhNldnospx1MWTHubRuNRuF2u3kZ2TUzIpEIvF4vpqenMT09Da/Xy/enZIcmsFNz5ufndZuaW3HmzBldnhRFgdfr5fmZnZ2FLMu2+2AalVKGVZlFZO08+0wmg3A4jMnJSbjdbl4HdmVuNq9sM3Zi/2MlS0b5LhQKlvL9sg5HsCKiHcxhlLv9yMvKazQahdPpRCwWQzgcxvLyMkZGRmz3fyWI/QwptcSBZGtrS6fEBoNBOBwOfPrpp7p0L0IkEsGlS5cAzcLECGqnURUKBa6sLywsoKury3Sy9vv9/ICIVCqFcrnMT6/x+/3Y2trip/DMzc2hVqvVKewisizj2LFjujwlk0nd4oGdtmSlmEajUYyOjqJUKumuW5XZSCaTwfnz57l1lW3iz47ztCtzs3k9efKk6fGrxP7CSpagyUGpVOJyEo/HbTfo3wmpVArnz58n6+IOMLYHOwWu1UM/CGK/YH6oNkHsMkY3csTEZdiKO//Ro0fw+/2QtaNhmRL4+PFj3XnvRgsSey6zRlarVfT29pq+79mzZ5iamsLW1hYPebDD6XTWKWbQzoOvVqu6idzuLHfxaN9oNIqOjg5d3k6fPo379++jr69P+JU9iqJgYGCAu9sfPXqEmzdvYnh4WGcNbbXMVrRaZiORSARdXV24f/8+fv/3f59fN5bDiNjeoitVtD5vb2+jXC439TszxNAJFurCOHToEK5fvw5JknSu9kQiAafTyY8sNb7DGL7DwjVYP/nkk0/4oiCbzQKAaWgHC89hx6JahXUwiyiTK2N/tHJJK4qCEydOAAAkScLt27ctZYkt/orFIr9mRTQa5e9LJBJYWFhoutxi3l0uF4aGhqCqKu9DxtAXCJ4GSZJw6tQpQDhGm/U/VVVx584dvPnmm7r2rFQqGBsbw+PHj9HT0wNJkixDnpjc1Wo1uN1utLW11YVgmMmT+JwXySuTPWPanYSANJLhZmWPIF4mZKkl9gWiGywWi8HpdFq68wFgfX0d1WqVWxT8fj/W19fx/PlzniYYDCIUCnEX+fT0NNxut86Fx95pVGgB4M6dO7hz547xMnK5HKrVqu6YxsHBQUiSZGnh2NzcNP33xsYGXC4XhoeHAQDDw8NwuVxcMY/H47q8RSIROBwOfPjhh/yaGSdPngQ0Kyg066hokfnFL35RNwHDpsyNiAjn3jOsymzEmFdo9bm0tITPP/9cSFlfDhFjSEQmk+Gu1DNnzgAAYrEYkskk2tvbLX9n54I1hk5Uq1VcuHCB3+/p6cGVK1cQi8WgqipOnz7N77W3t2NmZgbhcJgf3xzUjkw9ceIEpqeneTiGKFsOhwOHDh3i95gCFA6Hkc1medpgMIhz586hUChweR8aGjJ1Wefzebjdbv4O0bKuKIrOJV0qlTA4OMh/e/jwYdy7dw9nz55FKpWylCXG559/juvXryOdTuP69eum9RqPx7G6uqpbXDZbbiOSJKFYLPLf9fX11dVBRjtOWVVVnWLmdrsxOzvL2+/NN9/ElStX+MKFySoAvP7665iZmUEsFgMAnRwYaW9vRzKZrJOLRvKEXcrr0aNHsbi4iHA4jHK5bBkCMjg4yOXADCsZbkX2COJlQkotsecwi87i4iJyuRxyuRwWFxfh8XhMB14AqFarWF9fh9/v57/f2NjQpcnlcrh48SK3FrhcLjgcDl2aYrFoOyFbcfXqVaiqys9jf/bsGWq1mjFZQ5LJJLLZLEKhENLpNAKBACqVijEZoNXT8PAw5ubmLNNAmyj7+/sxPz/fsjVmJzClUHQzN4tZXhVFAbS6aQVmrRcV+fPnz6NSqXCLYS6XQyaTQaFQsPzd3bt3dddFfD4fyuUyz+v4+Lhu0cFCUtjCR6RUKnGFRFTyM5kM3nrrLX5P9DQAQK1Ww8LCAqBZ8lRV5W5iUeYDgQAcDgfPvzHsQ4SVNRAI1PU/ceEQDAbhdDp1v7VTeswIBAK4cuVKQ4XKSLPlNqKqKq+DSqXSUr9kbcTaj7U1e79V2sXFRd0iwYiVXDSSJztayWulUuEhTgsLC5AkqU6+o9Eouru7MTs7azkmWslwIBCAJEm8fVIUEkLsEaTUEnuOy+WCJElcsUun0wiFQpAkydSdz9jY2IDH48GJEyfgcDhMJ9pEIsGfOTQ01NIEZwdTmMPax3HMxbq2tmZMChhc70Y3fDwe58/54IMPIEmS6aQ9PDyMWq1mO1EwN/arcv0xl2O5XK6bjO3KDIu8BoNBBAIBrsy0QmdnJ1RVrVP4mXyJdSr+2+p3RpiCZ2d13gnBYBCXL1/mcnrs2DFjkqZwuVw4fPgwX2il02n09vaa1j1T7H0+H+9jrP9EIhHcuHED6XQaly5d4u7knWKMPTdTqA4iohxUKpWW479fljyZIYYCra2t1eU1Go2ir6/PNuzGDiZDVuMfQbwqSKkl9hxmWWBfSLO/RrsmLC0tweFw4I033sCTJ0/q0kYiEbjdbu7WnZmZ0d3fTewUI7NJy+wahA80zJ7j8/nQ29uLdDqNiYkJuFwu9Pf38/hIRVEgyzKmp6dfqUJbKBTqFFqz8onXrPIaCATgdrsxOjqqW9woitLQlbmxsWG6EGLyJVpAxX9b/c4Is4iZKYkvwvDwMCRJ4i7oe/fuGZM0RaVSwdOnT/lz2J+xbRgrKys4cuQIhoaGUK1Wef8ZHBxEqVRCOBzG2bNn6+KPm8VolWRsb29/IZQfUQ5cLlfdzg+NeFnyZIbT6eTW8Z6eHl1eo9EovF4vksnkjhRaCOOVVfgVQbwqSKklXgmVSgUOh4NbaPx+Pw8FyOVyKBaLGBgY4ANvIpHA5cuXbd2UmUwGT548wdGjR3WxnCLiR1fs44rdIBqNcmUyEomgr6+Pu2+NrKys8FhepmgzN10kEsG1a9d4TGQoFEK5XDadXMbHx7miEovFUKlUkM1mMT4+joi2dVImkzH97W7DYujK5XLdRzhoosxWeU2lUjh79iwv56y2PVwzE67oUoewDVIgEECxWNTFnno8HsvfmcX4MoyxqNFoFJcvX8bx48eNSVvC4XCgp6cHwWAQAwMDxttNwXaRYPmXZRnXr1+3jE1n6QcGBuos40wJYrHSOyWfz9fFnpstQA8iTA5Ym4lhBM1iJU92495OaG9v5/Itxs0qioK+vj7MzMy0nHeRpaUlqKrKQ12Y7LFQIoJ4VZBSS7wSUqkU/7AgnU7j0KFDuriveDyOarWKiYkJpNNpuN1uTE1NmSqJIvl83jLGz/jOUqlkunXUTrh58yacTifS6TRGR0exvLxsaR1NpVIoFAoYHR3F6OgoCoUCV9BSqRQePnyIsbExTExMAFq8LkNUnu3w+/1oa2vThXCk02mu0CiKsquTZSAQQHt7O7ccsz/2DrsyN8qrHXblyGgf1MiyzNtlfn4eqVQK8Xgc5XKZ17NoQTT+zm6STyaTKBQK3MXv9XoxNTWFBw8eGJM2zdzcHLa2tjA6OopLly7h448/BnZg9crlcpiamoLX60U6ncbY2Jhu0WGUJbaY3Nra0vWfhYUFtLe3Y2JiAqFQCB999JHO0tcKyWQS8/PzvL6cTieXb1mWce3aNW6Bz+fz6O3txeXLl9HV1WV40u7DFLHR0dEdKV9bW1tQFKWu3xrLZYeVPBnHvd3I68jICNKGsdXn86GtrY17Rtifoig8LKaZ95nJXqFQsBwTCeJlQSeKEQRBfAmQZRnf//738bOf/cx4a8/46U9/iocPHza0wu8nggfs9Djj9m0E8UWGLLUEQRBfAgKBAH7zm98YL+8ZwWAQhw8fNvWyEARB7ARSagmCIL4EJJPJfeUOzuVy+PM///M6VztBEMROofADgiAIgiAI4sBDllqCIAiCIAjiwENKLUEQBEEQBHHgIaWWIAiCIAiCOPBQTC2xK7AjT81QVRVXrlwx3fezVWTtFCsAdc9keahUKpicnNy1D1DYFj6Li4u6D20SiQR6e3sBAKurq7Zb5kSjUfT39wMAstmsbisgse6arSuzbYXEdwCwPSqX1aMkSabvbLZskUgEp06d4icUGdPalVt8x/b2tuURnYqiYGhoqC6PL0o0GoXH49k1WYlEIhgZGcHMzIxpOb4MRCIR/PCHP8T777/P24rJqrg/tFFO9gtWx8UqioKBgQFMTk7iwoUL2NzcrJNlt9utk1FRHvx+f52sGevF2AfM+riIsb8zrPq9sWxsDDA74tqYliAOCmSpJXaFZDJZdwoUO66z0XG3rcLOLTeeH+/z+XT/3w2MEw8jGo3C7XbzMrJrZkQiEXi9XkxPT2N6ehper5dvzM5O12JHBM/Pz+PcuXMNN7o/c+aMLk+KosDr9fL8zM7OQpZlyw3gT58+jXK5jHA4jHK5jNOnT/N70WgUTqcTsVgMk5OTcLvdpmWTZRkjIyPIZDIIh8N1ae3KLb4jHA5jeXkZIyMj/GQl8R1DQ0O6a8T+xLjAYbhcLjgcDn5ctd3RvYlEoqnDRl4mbW1tGBwcNF7mbG5uwuPx8D4aDAb5SYXimOT3+y0PhpFlGe+88w6KxSKvk9u3b+PUqVOmfQ3CCXlin65UKrwPsX4fCoXqDkwIBoPo6upCuVzmp36xQ0fYyX8MWZbh9XqRMTnx70UxKwNB7Cak1BIHkq2tLZ0SyyaWTz/9VJfuRYhEIrh06RKgWVAZQe2Y1UKhwJX1hYUFdHV1mSqj4uSWSqV0E4vf78fW1hbm5uYA7XSpWq1Wp7CLyLKMY8eO6fKUTCZ1iwd2BKpRGYf2e7fbzY8WXlhYwJEjR7hC2dHRgWq1ilwuh0wmg3K5bHo+fSaTwfnz57lVyJjWrtzxeBwXL17kVit2hK7xFK2TJ0/yRQyxf4lGoxgdHUWpVDLe4m26trZmvLUvUVUV3d3ddYohY2VlRXf8Nuurn3zyiW5M6ujoQLFYNPUCsEWlaIFNpVLIZDK6Y4VbJZlMIpvN6o4cB4Dh4WE4HA4UCgXd81m/DIVCPD3Lm5m1lyD2O6TUEq8ERVFw/fp1PpiardgTiQQ/prGRtebRo0c6RYxNLI8fP9ali0QiuHHjRt1zg9oRkOydZu979uwZpqamMDU1ZbxlitPpNFUiRSVRvGaFOGFGTY7JPX36NO7fv69TahshHi/LlIxKpcLvt7W18eubm5v8WFSjAtwKrZbbSCQSQVdXF+7fv6+7bndULgxtfuPGDS5jrM3ZdeNRrNFolMuJ3fPRIG1/f3+dvEGT78uXL+P69et1eYNWLva7tHBsMOsrf/EXf6G7J+ZBtO7JsszfkdaOPDXC6kL8nbGPiv1RzKuiKLh27RquXbvGrz969AixWMxUTlwuV5311oxoNIre3l709vYikUi0XG6rvs7qldUDqx9jv2KoqoqPPvoIQ0NDpsolU85Zf3G5XKjVashms3A4HAgGgwgGg3A6ndjY2DD8un5RKcKsusZFrax5RSRJwqlTp2wtnRsbG5AkSTcW+Xw+FItFfPjhh4Dh+bdu3YIkSRgeHkYkEoHb7cbCwgK/D0Fe3nvvPV7HoqzApt8xzMqQSCTw3nvv8X55/fp1/Pt//++5/Brl0ZjWrH3QRF9rlFfi4EJKLbEvEN3RsVgMTqfT0g0HAOvr66hWq3xi8fv9WF9fx/Pnz3maYDCIUCjE3ePT09N1rjb2TjN36J07d3Dnzh3jZeRyOVSrVZ3FY3BwEJIk1VkaGZubm6b/3tjYgMvlwvDwMKBZVFwuFzo7OwHNoinmLRKJwOFw8MnJipMnTwLCJJlMJnWW0e3tbT45r62t6ayh8Xgci4uLmJiYgKIomJmZacpqE4lE0N3drZusrcptZHBwsM5VOzg4iKWlJXz++ee6tMayiLCJk7V5JpPhYQ1nzpwBAMRiMSSTSbS3t/PfieEbsVgMAHDhwgV+X8QY6lGtVnlah8OBQ4cOcXkzWvza29sxMzODcDiMUqnELWSyLOPEiRPcRT87O6uTL/G5s7OzPJYyHA4jm83ytMFgEOfOnUOhUOB5GBoaqpu0c7kcisWizo3u8/lQLpeRyWSgKIouPKRUKulc8ocPH8a9e/dw9uxZpFIp/OIXvzBtDwDo7OyEJEkYGxuzVUbi8ThWV1d18batlNuqryeTSczOznIllVkizfo845e//CVUVeX9SCSTyeDJkyfc6+Dz+ZDP53UKaSAQgMPhMA09MFtUMiqVClRV5f2fwUIFVFVtGOfKnsveI8syjhw5gpWVFWQyGRQKBZ1FOZPJYH5+nvedQqFg+fz29nYkk0nEYjGoqsrDluz6HcOqDG63G7Ozs/yZb775Jq5cuYLJyUlAGMsA4OjRo1hcXERYC5uyC9Wy62uN8kocXEipJfacoObOX1xcRC6XQy6Xw+Liom7CNVKtVrG+vg6/389/b7SK5HI5XLx4kStkLLZPxMo92IirV69CVVU+UT979gy1Ws2YrCHMXRgKhZBOpxEIBEwnO2j1NDw8jLm5Ocs00JSu/v5+zM/PI7ODWOZEIoGBgQHEYjH8/Oc/RygUsl1gQJjUSqVSUwqwSDQaRXd3N2ZnZ3lbMEWw1WcxC5SozJ8/fx6VSgUej4e3N5vcGaJCx+TP7XabTnRiWgAYHx/nClKtVuNWrrW1tTqZKJVKfDIXlfxMJoO33nqL3zMqNeJzmeLDQjZEuWfK1N27dwHBvcwUMJGVlRVIkoRAIMAVH/YOceHArI4ixgWIHR0dHbrYz0bKiEiz5W7U15PJJMrlMsbGxuB2u3Hr1i1+z4xKpcIXFsYFAbS26+joQFALe6pUKsjlcjzkh1lv7frpqyIQCKBWq/H2WllZ0Xm5oIU9bW1tQVVV3Lx5U/i1HhZyxRb2DKt+18z4w/oEeybrW6y9RSqVCg/VWlhY4PJrhlVfe5G8EvsfUmqJPcflckGSJK7YpdNphEKhOheakY2NDXg8Hpw4ccLSKiK6UIeGhuqUjJ3CJtGw9oFGsVgEbOIGRbe70QUfj8f5cz744ANIklSnoEOz4tZqNUsrCoSdFKy+gGaI4QY9PT3cPSxrrlHjAsMuzk+2+Yrartyw+Mo6GAwiEAjUuUCbobOzE6qq1ikTTMbEemX/Pn78OJxOp60lmcEUvGbStkJQCI1Ip9M4duyYMUlTuFwuHD58mC+20uk0ent7TeteVHh7enpQrVZ5HxLds5cuXYIkScafN834+LjOst5IGdkpjfr6wsICtre3m17sifGmX/3qV3X3WFztiRMnAEFByufz8Pl86OzstFwwszHCbGwzk9NWYc9dW1tDMBjEwMAAXC4XJiYmkE6nMTo6isOHD+ssoEyhNIYLNYtVv9ttxPwZPUzN8qrySuwNpNQSew5bkbMdANhfo9Xz0tISHA4H3njjDTx58qQuLYsPYy7dmZkZ3f3dxG6gNFOAzK6hgWvS5/Oht7cX6XQaExMTcLlc6O/v18UOyrKM6elpW4XWbDIQwxFagSm0hUKhTqE1K6N4LRqNwuv1IplM6hT1QCAAt9uN0dFR3QJHURRTq5mIWTwhLNy67N8PHjxAtVo1VfyMsMm/mbStMDw8DEmSeEjDvXv3jEmaolKp4OnTp/w57M/YNox8Pg+Px4P+/n6sr69zhWFwcBClUgnhcBhnz55FuVw2/vSF2Km8WdGor7PwhLa2NstYWTNYvOk3v/lN3fUl7UPMrq4u1Go1Xm+VSgUOhwMdHR3comwko31QabZbi9GKuBN8Ph8fi5jl3igP2WzW1hPWKlb9brdhsf4wLMZb4VXlldgbSKklXglssGeDtt/v5+7BnBbfJ36xywL97QbdjBbbdvToUdOPLmD46GpwcLAu/GCnRIUPuCKRCPr6+rh108jKygqP72OTL5vwIpEIrl27BlmICyyXy6bW2PHxcT4pxWIxVCoVZLNZjI+PI6JtDZZpYhseVm8sRnJwcJAvCtiEy9qCWXpEdzsjqMVvlg1fcTPsyq0oCvr6+jAzM1P33FQqhbNnz/Kysi3ijMqvGWJcI4SPrAKBAIrFoi4G0+Px8N/l83kebmBXZmNaaLJw+fLlug/PWsXhcKCnp4e/fycwZYtZ4WTtoyir8JGlpSVIkoTXX3+dhywwmALBYqV3ArNAs/czGTdbhL4odn1djKcuG7awsyOjxZuy/ZQZuVwOz58/xze+8Q3d2MPkz+l02irtt27dgtuwVR7rw+KuKq2iKAp6e3v5WOT3+03rWgw92Q2s+l2jRWirtLe383eYxeE3w6vKK7E3kFJLvBJSqRQP1k+n0zh06JAuXioej6NarXIXmdvtxtTUlKmSKJLP5y0HNuM7S6WS5TZXrXLz5k04nU7uzlteXra0jqZSKRQKBYyOjmJ0dFT3IUYqlcLDhw8xNjaGiYkJQIvXZYjKsx1+vx9tbW26EI608HW4YtgxgE2qrK7FGEP2/omJCUxMTKBarZpa+gKBANrb27n1mP2x99iV2+fzoa2tjVtj2Z/4UZUVxrKIZLSPUWRZ5m0zPz+PVCqFeDzO4ypZuRjJZBKFQsGyHUTEtOl0Gl6vF1NTU1hfXzcmbRoW0zg6OopLly7h448/Bky2OGtELpfD1NQUvF4v0uk0xsbGdIsOozyxRYxRgV9YWEB7ezsmJiYQCoXw0Ucf6axkzZLL5TA5OQmPx4O05mGAULeyLOPatWtcocjn8+jt7W15kWDX11mIC4vZNlMo7bCKYX/48CHcbrfuXk6Lq61Wq3WKpEgmk8G7777L6yWdTuPUqVO4ffu26QIRmjKmqipGR0d5PxHDCtLptM5TwxZuZgt+9iy7/XiNbWOHXb8TMStDK2xtbWFkZARpwxzxMvJKHEzoRDGCIIgvCbIs4/vf/z5+9rOfGW/tGT/96U/x8OFDUioIW9hizGyBTRAMstQSBEF8SQgEAvjNb35jvLxnBINBHD582NTTQhAE0SpkqSUIgiAIYl9DllqiGUipJQiCIAiCIA48FH5AEARBEARBHHhIqSUIgiAIgiAOPBR+QOwK7CQrM1RVxZUrV2y3uGkWWdvsH0DdM1keKpUKJicnG24H1izBYBBjY2NYXFzUbduVSCT4/pXiefVmRKNRfm59NpvVbdsj1l2zdcXyVCwWdds1sXcAsD1VjNWjJEmm7xSfZVefkUgEp06d4pugG+vBrtxi/W1vb1ueaa8oCoaGhury+KJEo1F4PB7Lsr1MxPo31ssXAbaNlrFNFUXBwMAAJicnceHCBWxubtbJhNvt1rV1JBLByMgIZmZm4Pf769qM9QW2VZ+ZLO1lW8PQ3iJWfYulF0/ps6pTs7St0kq8qlU+XrRtXS5XXT9/0bY1jokMq7HRWDa7ujWmJfYHZKkldoVkMlm3WT47xabRyWCtwk7DMm4cbnZCz4tiHFQZ0WgUbrebl5FdMyMSicDr9WJ6ehrT09O68+TZhuvsNLX5+XmcO3eu4X6gZ86c0eVJURR4vV6en9nZWciybLlv4+nTp1EulxEOh+s2o2cHI7DTmarVKi5cuKD7PbTJdGRkBJlMBuFwGJOTk7r9P+3KHY1G4XQ6EYvFEA6Hsby8jJGREciGk55kWcbQ0JDu2heBkydPQlVVxGKxL5xCy2hra7PdB3Vzc1N3qlUwGOQHJoh92+/3W+5FLcsy3nnnHRSLRT7+3L59G6dOnbLtj3u12b54amIsFgMAjI2N1fX3QCAAVVXhdDp5n4jH4yiVSnV1ymTJal/ll8F+bVtZO2xE3AO3UqnwcYaNjaFQqG6f3GAwiK6uLpS1o6Mh7GnLDpFhyLIMr9eLTBOH3RCvFlJqiQPJ1taWTollg+ann36qS/ciRCIRXLp0CdAsqAy2qbl48s/CwgK6urrqJicYBu6Udp48GzT9fj+2trYwNzcHaBu912q1OoVdRJZlHDt2TJenZDKpWzywk6WMyji037vdbr4p+8LCAo4cOcInT5/Ph+XlZT5Yj4+P11kpoA3458+f5xaPjLaRPztC1q7c8XgcFy9e5JYVdtKY8bCBkydP1h3p+0VBPMf+i4iqquju7q5THhgrKyu6U8CYzH/yySe6vt3R0YFisWhaV2xxJi4MUqkUMpkMPz1uv8IOypAkCcPDw/x6UDtRbnl5GdD6AGNhYUFXp2zhyA6WeFUc5LZNJpPIZrO6EyyhHVXtcDhQKBR0z2djVygU4ulZ3sysvcTeQkot8UpQFAXXr1/nA4WZtSSRSPCTcRqdovXo0SOdIsYGzcePH+vSRSIR3Lhxo+65Qe34TvZOs/c9e/YMU1NTmJqaMt4yxel0miqRHR0ddQoMU/zMECeDqMmJYqdPn8b9+/d1Sm0jFOEULqY4iichtbW1oaenhyu8Gxsbwq93RqvlNhKJRNDV1YX79+/rrotlMUNs8xs3bnAZY23OrhtPrIpGo1xO7J5vJKIddcyebTXRM5hLtLe3V9cnGAntiOjr16/XlQGCNYrl1ep9dums6oj1y7/4i7/gv2NWMWO9yw1OcVJVFR999BGGhobqygiAHyPL5NHlcqFWqyGbzcLhcCCoHdPsdDpN5dG4OBMxHoXK+O53v4uRkRFIkoRTp07xvFu1PRu3/vIv/1JXj+JYxerVKq0dlUoFqqqis7OTXwsEAnA4HPjwww9RLBZ1Fs9UKoXl5WWukA0ODqJscay22MbXrl3DtWvXEI1GLcc+h8PBZdhMLkX2Y9seP34c586dgyRJppZYkY2NDUiSpBuvfT4fisUiPvzwQ8Dw/Fu3bvHFR0Q78nthYYHfZzTqu1b9jtg9SKkl9gWiOzoWi8HpdFq6mABgfX0d1WqVD5p+vx/r6+t4/vw5TxPUzpln7vHp6ek6NxJ7p5kl8s6dO7hz547xMnK5HKrVqm41Pzg4CEmS6iyNjM3NTdN/b2xswOVycUvN8PAwXC4Xn+Ti8bgub5FIhE94djDrDpsAksmkzjK6vb3NJ561tTWdNXR7exvt7e188G1WwYtEIuju7tZNRFblNmJ2jvvg4CCWlpbw+eef69IayyIiG0IiMpkMD2s4c+YMACAWiyGZTKK9vZ3/ThHCN5hb2CzkwgpJkribtJH1Jh6PI5vNolKp4N133zUNzWlvb8fMzAzC4TA//pUpAufOnUOhUOAyPTQ0VDc52qUz1pEx9MPhcKCzsxOxWAzT09Po6+uDoihYWlqCw+Hgk30gEECtVjN1HTN++ctfQlVVnbWRkclk8OTJE2699/l8yOfzOqWFKXhm7zBbnDHMlEUAuH//PmZmZqCqKo+FFNs+bBJuI0kSnj17hnA4jGw2i1AohHw+j3A4jNXVVZ3FT5IkvPbaa9zNLduEAEEYS8TFnt/vx5MnT5DJZHD37l1dnUM7ohsA/tN/+k91R1wz2Ni3vLyMcDiMe/fu4fDhw7o0xrHv6NGjWFxcRFgLSWoUBrXf2vbBgweYmpqCqqqWMbMM9lz2HlmWceTIEaysrCCTyaBQKOgsyplMBvPz87zviEd+G7Hqu8Z+J45NxO5BSi2x5wQ1d/7i4iJyuRxyuRwWFxd1Fgoj1WoV6+vr8Pv9/PfGFX8ul8PFixf54OZyuXhcF8PK9dWIq1evQlVVjI2NIZ1O49mzZ6jVasZkDWGuMHZmfSAQMB3IodXT8PCw5Vn0DEVR0N/fj/n5eVOFqRFtbW341re+hZ///OdNK3hswC6VSraTiRnRaBTd3d06FyqzsrT6LDb5i8r8+fPnUalU4PF4eHuziYvh8/lQLpeRyWS4/Lnd7qYnnFqtxkModoNSqcQnTXExEAgEIEkSf1cqlcL58+frJli7dMY6unv3Lv8Ng/XFVCqFUqkEn89nqqg06j+VSgWzs7O6eGqRzc1NdHR0IKiFD1UqFeRyOR46wyx8dvL+ovh8vrpQItELpKoqr6ONjQ3d4su4UNve3uYWvLm5OWxtbfH6agY2lrGFobHOoY1ri4uLOHz4sGUfN7a/2ZhhbLtKpcLDoBYWFiBJUp01VOQgtG2zGBdoKysrOhmA0J6qqvKFhRl2fRcmY5NZ+xE7h5RaYs9xuVzcZcTcdqFQqM49ZGRjYwMejwcnTpywXPGLbsKhoaEdKZ5mMIU5rH18UCwWAcHtZkS0xBhd8PF4nD/ngw8+gCRJdQo6NCturVarU2BEFG0nhUaWChZuAM1awXYvYBgXGHYKnmzzhbBduWHxBXEwGEQgEDB17zWis7MTqqrWTZRMxsR6Zf8+fvw4nE5nnYJihmxw6dt5Exiia7uRW7cRrD9YyRnDLp1VHTGMioZYL/l8Hh6PB7Isw+FwNKXIizGJX/3qV3X3WOzliRMnAGHCz+fz8Pl86OzsrFO+GKxsZmOEWXubEdRc4P39/byNRkdHbb0udtRqNZ6vnGaFtYO9n9Ux89SIY2Fvb29dDCmzVlq1oV37WyGGChm9N1bs57a1Q6yfoBbD7HK5MDExwWXg8OHDOis0a09jSFWzNOp3xO5ASi2x57ABWvwyONzErgnMHfrGG29wd50Ii31iX/HPzMzo7u8mdgOWmbJkdg0N3G4+nw+9vb1Ip9OYmJiAy+VCf38/j4lTFAWyLGN6etpWoTWbsFg4AmsLI1ZlYwptoVCoU2jNyihei0aj8Hq9SCaTOkU9EAjA7XZjdHRUt8BRFMXUIiRiFisHC5cl+/eDBw/qXMBWZLSP45iMNrNzgbhoaSTTjWBt0EjhsktnVUcMhxDTDcNihPU5tiOF2ULSDBaT+M1vflN3fUn7oLGrqwu1Wo0rC5VKBQ6HAx0dHZaKc0b7MNFs1xOjVcwKpqhks1nd2HP27FnbxaMVDoeD1zlTWO0IBAJob2/nCprP56vLy+TkJE/bLHbt3wxmC10r9mvb2uHz+fiYFtDCIFj4CfvLZrO23sJWadTviN2BlFrilcAGMjYg+f1+HgqQy+VQLBZ1sWks4N5uQGGuuaNHj5p+UADDBD04OMjf+aKIH3BFIhH09fVx66aRlZUVHsvLFG02mEe0j4xkWUZQi4Oz+vBjfHycD7ixWAyVSgXZbBbj4+M8VjLTxBYzrN7YljyDg4N8UWBsC2bFMLOoBLW4TeMXygy7civatmEzMzN1Sl4qlcLZs2d5WdkWcUbl1ww20TE5i2gfPgUCARSLRW7xYm5eRj6f59ZoVmYWjrCfWFpagqqq3B3NLMfGj2Ls0hnryBh/DWF7PGOcNJOd733vezpFpREZLSaR7UvMyOVyeP78Ob7xjW/o+jDLi9PptLU23rp1C25hGzloeZZlWRdSYEc+n9dZQqPR6I4t6m1tbbzOh4eH0d7ebqm4sf7Odj+RhbhOETsFzwpj+zMLsB3d3d180WgW427Ffm5bMxRFQW9vLx+vxRhmkZWVlYYhGK1g7HdsbGq0UCdag5Ra4pXAYvOYW+3QoUM6i2A8Hke1WuXuH7fbjampqYaTZj6ftxx8je8slUo8nutFuXnzJpxOJ3dVLS8vW1pHU6kUCoUCRkdHMTo6qvvIIJVK4eHDhxgbG8PExASgxesyROXZDr/fj7a2Np3bUnSPK4Yv19mEwepa/NgkHo+jWCxiYmICExMTqFarpkorszIx6zH7Y++xK7fP50NbWxu3xrI/o3JmhrEsIhltX0lZlnnbzM/PI5VKIR6Po1wu87oWXcPJZBKFQsGyHfYLOW0bKK/Xi3Q6jbGxMRQKhTrZs0tnrCPj4qJWq8HhcFjKNlNQrBaSVpjFdQLAw4cP4Xa7dfdyWuxltVqtUzZEMpkM3n33XXg8Hi5Dp06dwu3bt01lFoLCNzo6CkVRdG1vVh+toKoqz0tI+0hVXIiJ/ZPJIPvo0RjXKZLP53VKpxniWJHL5TA7O4u+vj6kG8TqM1gYQbqF8ZexX9qWLQBCoRAf+8SwgnQ6rfNmscWtmSwzObHbj1dusAOIiLHfiWMTsXvQiWIEQRAEoFmP2AlPVpNtJBLBD3/4Q7z//vu2SsmXDeUlnXy3GwQtTkUkiC8aZKklCIIgmsbKXUvsH4wWRBYKYWZNJYgvEqTUEgRBEA0Japv2e71e071Rif1DJpPBw4cPdR9bGkMhCOKLCIUfEARBEARBEAcestQSBEEQBEEQBx5SagmCIAiCIIgDz56HHyQSCd3+duJJSNFoFP39/ULq+jQM9nUn265pe3tbd0oR8eqwa1PxC+FAILCvvhZuRd5eFrJ2mIEkSYC2RdB+qZ+DCtvmyHg4xIsiynmz442iKBgYGMDk5GTD7ZISiQQ2Nzctty9iJBIJ5PN5VCqVhjsXvArYVkos3yx/u9WHXlZ77mfY/FYsFhvKA6PVem/lHa0+myBeFXtmqQUP/KkAAAz/SURBVGUfHTidTsRiMYTDYUxPT0OWZd1elZVKhd9nG7GHQiFdGlmW8c4776BYLPJ0t2/fxqlTp5o6xpLYHZpt05fJi25o3Yy82ZFIJJraV9aMSCQCRVEwPz/P3z8/P4+xsbGm37+bvEhZvuhEo1GdnC8vL2NkZMR2w35FO8K4GYwLQyuYXDSjXIjt+aL9xI6Ojg5+QlYwGITD4dj3X92/zPrYC152vd+6dQsDAwO28k4Qe8GeKbXDw8OQJEm3wXMqlcLy8rLuZCkjyWQS2WxWl+b06dN1pxqlUilkMpm6M7OJl0erbZpMJl/42NCXjZm8vQyC2ulCxo3uX9X7v8iMj4/vulUvHo/zTfOhnT4Em2NJE4kEZFnGp59+arylQ9ZO/jpy5AiePn1qvK0jGAwiEAhgYWHBeGvPkGUZTqez7vQkswMFdsrLaM8vGi+j3kUymQyKxSI/jY4g9gt7Fn7QjAspGo3C4/HUuepEFzYAvP3225ifn6+zVjBXrtk92ox692mmTa3CD06fPg2Hw8GPtVVVFXfu3MGbb74JSZLq3PCiJYu5ftfW1rjrXnQHi2EFlUqlTp4YzchbJpNBJBLBqVOn+Nnoq6urGB8f172HXTNa57LZrKlrz27Te/EeAIyMjOCTTz7hR2AanynWDcsHu+5wOOB2u7G1tYXJyUkEAoGmy2IMjWBhGawvVatV9Pb2YnV1FQsLC7rnmoVwmLk7jXVtVRZFUXDixAkAgCRJuH37NgYHB3lasZ2NcmklD+zdqqryMCZj3Vph137Q8ptMJi1ljCHLMrq7u/HP//zPdXVjJBKJYHh4GH/913+NXC7H8yDKhll7VioVSJKk6yfsCGmx/7E2YO3E6kRsh2g0io6ODl27iOEV7P7Vq1cxNjaGx48fo6enB5IkoVKpYGFhAT/4wQ/Q1tbG2wKAaVqz9mQyvZNxw0yuzcJIzOo1m80CAK9TJidMhtbW1vCtb30LMMi+WJfb29sol8twOBym8iCOM2yB8/DhQy4PxjYVn2FsF7NyN/MOq9/BpK0JYj+wJ5baYDAIp9OJzc1N462mYC6Vnp4ebhkxc7NUKhWoqorOzk7jLeRyOVy8eLFuoiV2xou2KQC43W7Mzs4iFotBVVW8+eabuHLlCp/omFVAURSd67dUKmFwcJAfQ6iqKp+YFEWB1+vF5OQkwuEwqtUqLly4YHizPaK8MYtqJpPh4RVutxuRSATxeByrq6u6yfLEiROYnp7moQxWngOmMJidhc6usTQOhwOdnZ2IxWKYnp5GX18fd0OLbvFYLAan06kLwWlvb0cymcTFixcB7djOZsoSDAZx7tw5FAoFXhZZlnXuWvbeq1ev1j33xIkTdeXO5XIoFovweDzcCu3z+VAul5HJZBqW5fDhw7h37x7Onj0Ll8ulk4lqtYozZ84Ib/u/iPIQi8UAQCcPkiTxMCZ2zGgzLunBwUHL45rRZHgANAvYBx98YLxsit/vR61W0ykUDocDhw4d4vXe3d0NRVF07Xnx4sW6fgIAR48exeLiIsLhMMrlMs6dO4dgMIgzZ86gWq0iHA7zdmDyFo/HdYpOZ2cnisUiz1NHR4fuCNKenh7epyVJwuDgIH7+859jenoa7e3tGB4e5mlff/11zMzMmLaTSLPjhpU8mY0bRsR6nZ2d5cpkOBxGNpvV9WtJkvDaa6+Z9hMmk7FYDMlkEu3t7cJb/h+i5yYcDuPevXs4fPgwv99oXBPr3arcjd4h/m5ychJut1vX/5aWluBwOLhVmCD2A3ui1BKEGaVSCalUCrlcDtVqlSs3bHHCYEpZLpfjyrQVPp8PhUKBW2oWFhZw5MiROgWrWYyLIZfLBYfDYUwGaArKW2+9xSdJs8XVTllcXEQul0MqlUKpVILP50NQO8ec3cvlclhcXNQpjaxO0WJZAoEAJEnibva5uTlsbW1xyxUAnTIDgIdMpFIpvPXWW/y9IisrK5AkCYFAALIs48iRI1hYWGiqLEYl0uVycaVofHzc1MIpKs3smW63m8uDqqq4e/cuoC1marWa4Qn1RKNRdHd3Y3Z29pVarDo6OuoWkbVajYcjrK2tNZV/RqVSwdzcHKD1E9YuANDd3Y1IJFInMyLBYBBdXV1cRoyhCAB4X2R9msmMWV7F8cDYTlbprMaNZuTJDrFe2XNZOVn8MGN7e5unFfsJywMrcyaTQaFQ0P2WYdbfRMON3bgm1rvxnaz94vG47TuMv2N5NdZXW1sbX2wTxH5gT5RaNvh0dHQYbzWFaNUyWrFEXC4XJEmqG3SI3edF27QVIpEIbty4gXQ6jUuXLkHS3OFGmMLb39+PdDqNdDqN0dFRSJJkGftohtGKmkgk+POGhobqJmNGUPtwjqU9duyYMQlHtAYbMXojarWaboJjig2T91AoxN8ZCoUgSZJp/0ALZTHWgR25XI5bySYmJpBOp3H58mVT5SGVSqFcLsPv96OnpwfVahVLS0stlyWZTPKP+lh6Zk1kMHkwKoIvQjQaRV9fn6WF7yBRrVa5Ur62tobt7W1As8YuLy/z06lu3Lhhar1miyImIz09PXWy2gpiO1UqFZ6fndCqPL0ItVqN1wEbF9HifGTsb+JzGo1rYr3bvdPuHXa/YxiNDQSxH9gTpRYA8vm86cpbURRcv3697rqIz+eDqqqoVCrIZDIol8vw+XzGZC89WJ7Q8yJt2gqDg4MolUoIh8M4e/YsyuWyMQkgDNLZbBZhbTcB9ptWFBBR3iKRCNxuNw8pYHGuZrAP55iL8N69e8YknKWlJaiqqrN8Mvx+v84qyeIHGWwhwSaZ2dlZXXmtPsZrpSx2SrcZzCIUDoe5q9ksHACa3Hg8HvT392N9fR25XK7lskBTbFm6bDaLoaEhnczt9sIrGo3C6/UimUy2JE/7FafTyRcePT09PB4ammLL6rZUKiEUCtUtUgKBAKrVKm8fv9/P23MniO3kcrl0+WmVncjTTnE4HLyfMAUUDcLhjBj7m/icRuOaWO9277R7h93vGEzxJYj9xJ4ptXNzc1BVlcdtQXNXDQ0N6dwqRhRFQW9vL3cjQdtexBjvE4lEIMuy7bOI3WWnbboT2AQciUTQ3d1tvM3J5/O6eLdoNNqSgm0mb6JSyT6wsYJNcMFgEAMDA8bbnFwux2M4RQujoijo7+/XvR+aog1Nzru7u5HP55HTYlTFnRISiYSllRQtlMWodA8PD6O9vZ27LkVk7Qt+Vg42QVpZfZaWliBJEl5//XXu+m+1LNFoVHdvY2ODL0RExIUXaxMxJKNZFEVBX18fZmZmWv7tbrG5ublrCjq0eGtmCBBjhBOGrd02Nzd1Vl2Gz+fjcZxBQyjCTtiNdmK0Kk8vQltbm2k/YXlgLnxZluH1eo0/B4T+Njg4CGgLBjH+1mpc+/GPf6yrd+M7IWztZvcO4+9YXo0hRtvb23V9jCD2kj1TanOaJadarXIX5djYGObn53WxcC6Xi99Pp9OQZRnT09O6mK5MJoN3330XHo+Hpzt16hRu375tGlcHwTVsdFESO6fZNn1RFhYW0N7ejomJCYRCIXz00UdcyWUD9ejoKBTti/NCoYCxsTGk0+mGikgjeWMxrMyNWSqVUKvVuGKYz+fR29uLy5cvY3V1FVtbWxgdHcWlS5fw8ccfAzbWzlQqhWQyiaGhIf7+oaEhTE5O6uS9VqvB4XBwt6O4DVg8HtfVv9vt1m2xJtJKWQBgamoKXq8Xac11m8lkTC2UGe3DG1mWkU6nMTExgWq1ahqHCS19uVyuU1paKYsxrSzLpjGuojxMTEwAAK5evapL0ww+nw9tbW3cJc/+FEVpaWxpJa2RlZUVOByOppUysT2r1aqunwDA1tYWRkZG6ur66tWrcDqdvIxerxe3bt0CNGUqkUggaNgX1WUIRdgJW1tbUBTlhdpJxCgjYhmN4wYr105QVZXPRcZ+cvPmTUALy3n77bd19aMoCleyc7kcpqam4Ha7kU6nMTIygq2tLZ7WalxbXV2tq3djuZ1OJ65evdrwHeLvxsbG6rbNDAQCqNVq5Akl9hV7tqUXQRCtw7YXsto6ivjyEAwG8ad/+qeYm5t7YVkQt8naa4ImW70dFBTDlnSNiBq23jpIJJo88Y4gXiV7ZqklCIIgdg6zMDL3MbH/SSQSPEyOufR388PFV4Ws7bDAwoUIYr9ASi1BEMQBhYV07CR8gXj1LCwsoK+vD2ktNMvo0j8onD59GouLi01ZowniVULhBwRBEARBEMSBhyy1BEEQBEEQxIGHlFqCIAiCIAjiwENKLUEQBEEQBHHgIaWWIAiCIAiCOPCQUksQBEEQBEEceEipJQiCIAiCIA48pNQSBEEQBEEQBx5SagmCIAiCIIgDDym1BEEQBEEQxIGHlFqCIAiCIAjiwENKLUEQBEEQBHHgIaWWIAiCIAiCOPCQUksQBEEQBEEceP7/8TuyhLLNo2oAAAAASUVORK5CYII=)
"""

# import geopandas as gpd
# import xarray
# import rioxarray

# # DTM [50m] import
# dtm_piemonte = rioxarray.open_rasterio(shapefile_path + 'DTMPiemonte_filled_50m.tif')
# dtm_piemonte = dtm_piemonte.rio.reproject("epsg:4326")
# dtm_piemonte = dtm_piemonte.where(dtm_piemonte != -99999) # Take valid pixel

# # Catchment shapefile
# catchment = gpd.read_file(shapefile_path + "BAC_01_bacialti.shp") # select GRANA-MAIRA	and VARAITA
# catchment = catchment.to_crs('epsg:4326')

# # Select only the Grana-Maira catchment
# catchment_GM = catchment.loc[catchment.NOME == "GRANA-MAIRA"]
# catchment_GM = catchment_GM.reset_index(drop = True)

# # Retrieve the borders of the catchment from the shapefile
# xmin_clip, ymin_clip, xmax_clip, ymax_clip = catchment_GM.total_bounds
# # Extend the borders to include more pixel on the borders

# increase = 0.05 # Degrees
# #ymin_clip -= increase # not needed
# xmin_clip += increase # "+" for subset for pixel included in the mask
# xmax_clip += increase
# #ymax_clip += increase # not needed

# dtm_piemonte_clipped = dtm_piemonte.rio.clip_box( minx = xmin_clip, maxx= xmax_clip , miny= ymin_clip , maxy= ymax_clip)

# dtm_piemonte_clipped

# import numpy as np

# # Definizione delle coordinate
# lon = np.array([6.938, 7.063, 7.188, 7.313, 7.438, 7.563, 7.688, 7.813])  # 8 valori
# lat = np.array([44.313, 44.438, 44.563, 44.688, 44.813])  # 5 valori

# # Creazione di una griglia lat-lon 5x8
# lon_grid, lat_grid = np.meshgrid(lon, lat)

# # Creazione di un array 5x8x3
# img = np.zeros((5, 8, 3))

# # Assegno le coordinate nei primi due canali
# img[:, :, 0] = lat_grid  # Canale 0 = latitudine
# img[:, :, 1] = lon_grid  # Canale 1 = longitudine
# img[:, :, 2] = 0  # Canale 2 = valore placeholder

# for nr_lat,latitude in enumerate(lat):
#   for  nr_lon,longitude in enumerate(lon):
#     img[nr_lat, nr_lon, 2] = dtm_piemonte_clipped.sel(x=longitude, y=latitude, method='nearest').values

# img = np.nan_to_num(img, nan=0.0)

# img

# from skimage.segmentation import slic
# import matplotlib.pyplot as plt

# segments = slic(img, n_segments=8, compactness=15.0)

# plt.imshow(segments, cmap='jet', alpha=0.6, origin = "lower")
# plt.show()

segments = np.array([[1, 1, 1, 1, 1, 2, 2, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [5, 5, 4, 4, 6, 7, 7, 8],
       [5, 5, 6, 6, 6, 7, 7, 8]])

segments

segments = np.array([[1, 1, 1, 1, 1, 2, 2, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [5, 5, 4, 4, 6, 7, 7, 8],
       [5, 5, 6, 6, 6, 7, 7, 8]])

# Creazione superpixels

# Trova i valori unici nella matrice (i cluster)
clusters = np.unique(segments)

# Creazione di una lista di matrici binarie per ogni cluster
binary_matrices = {}

for cluster in clusters:
    binary_matrices[cluster] = (segments == cluster).astype(int)

spatial_superpixels = [matrix for _, matrix in binary_matrices.items()]

spatial_superpixels



"""#### ***Generazione e Applicazione Maschere Uniformi (3D)***"""

import numpy as np
from tqdm import tqdm

def generate_masks_uniform_noise(spatial_superpixel_clusters, temporal_superpixels, shape, beta):
  time_steps, height, width, channels = shape
  masks = []

  for t_sp in temporal_superpixels:
    start, end, _ = t_sp

    for cluster in spatial_superpixel_clusters:
      mask = np.zeros((time_steps, height, width))
      for h, w in cluster:
        mask[start:end+1, h, w] = beta

      masks.append(mask)

  return np.array(masks)

# Questa funzione non somma le maschere gaussiane. Ma aggiunge rumore singolarmente alla istanza basandosi sula valore di z_i in zs_primes

import copy

def perturb_instance(instance, zs_primes, superpixels, channel):
  masked = []
  for z in zs_primes:
    masked_instance = copy.deepcopy(instance)
    for i,z_i in enumerate(z):
      if z_i == 0:
        masked_instance[..., channel] = np.add(masked_instance[..., channel], superpixels[i])

    masked.append(masked_instance)

  return masked

"""#### ***Rappresentazioni Interpretabili***

Ho 45 features in questo caso. Non posso generare tutte le 2^45 combinazioni!
"""

# temporal_superpixels

import numpy as np

def generate_contiguous_ones(length, n):
    results = []

    # Scorrere la lista con finestra di grandezza n
    for i in range(length - n + 1):
        # Creare un vettore di zeri
        vec = np.zeros(length, dtype=int)
        # Impostare a 1 gli elementi contigui nella finestra [i:i+n]
        vec[i:i + n] = 1
        # Aggiungere il vettore alla lista dei risultati
        results.append(vec)

    return np.array(results)

import itertools

# Crea vettori con unico 0 per ogni elemento
def create_zs_each_superpixel_foreach_season(n):
  zs_primes = []
  for i in range(n):
      # Crea un vettore di zeri
      vec = np.ones(n, dtype=int)
      # Imposta un solo elemento a 1
      vec[i] = 0
      # Aggiungi il vettore alla lista delle permutazioni
      zs_primes.append(vec)
  return zs_primes

# Crea zs_primes con tutti 0 per ogni stagione
def create_zs_season(masks, spatial_superpixels):
  zs_primes = []
  len_masks = len(masks)
  nr_spatial_superpixel = len(spatial_superpixels)

  # Itera da 0 fino a len_masks con step di nr_spatial_superpixel
  for i in range(0, len_masks, nr_spatial_superpixel):
    # Crea un vettore di 1
    vec = np.ones(len_masks, dtype=int)
    # Imposta a 0 gli elementi nell'intervallo [i : i + nr_spatial_superpixel], ma con controllo limiti
    vec[i:i + nr_spatial_superpixel] = 0
    # Aggiungi il vettore risultante alla lista
    zs_primes.append(vec)
  return zs_primes

def create_zs_superpixel_foreach_season(masks, spatial_superpixels, temporal_superpixels, seasons_to_perturb):
    """ Perturba i superpixel per ogni stagione in base ai vettori binari passati. """
    zs_primes = []
    len_masks = len(masks)
    nr_spatial_superpixel = len(spatial_superpixels)  # Numero di superpixel spaziali
    nr_temporal_superpixel = len(temporal_superpixels)  # Numero di superpixel temporali

    for i in range(nr_spatial_superpixel):  # Ciclo su ogni superpixel spaziale
        vec = np.ones(len_masks, dtype=int)  # Inizializza il vettore con tutti 1
        for j, s in enumerate(seasons_to_perturb):  # Ciclo sulle stagioni da perturbare
            if s == 1:  # Se la stagione deve essere perturbata
                # Modifica il valore nel vettore per il superpixel temporale corrente
                # Qui si fa il calcolo corretto per identificare la stagione temporale
                temporal_index = nr_spatial_superpixel * j + i
                if temporal_index < len_masks:  # Verifica che l'indice temporale sia valido
                    vec[temporal_index] = 0

        zs_primes.append(vec)  # Aggiungi il vettore perturbato alla lista

    return zs_primes

def create_zs_superpixel_for_contiguous_frame(masks, spatial_superpixels, temporal_superpixels):
    """ Crea una lista di vettori per perturbare i superpixel durante le stagioni
        con blocchi di 1 contigui.
    """
    zs_prime = []  # Lista che conterrà i risultati finali
    nr_temporal_superpixel = len(temporal_superpixels)

    # Ciclo attraverso i vari n (numero di stagioni da perturbare)
    for n in range(0, nr_temporal_superpixel):
        binary_vectors = generate_contiguous_ones(nr_temporal_superpixel, n)  # Vettori con blocchi di 1 contigui

        # Ciclo su ciascun vettore binario generato
        for bv in binary_vectors:
            #print("Binary Vector:", bv)
            vecs = create_zs_superpixel_foreach_season(masks, spatial_superpixels, temporal_superpixels, bv)
            zs_prime.append(vecs)
            #print("Perturbed Vectors:", vecs)
            #print("\n ----------- \n")

    # Appiattisce la lista di liste in una lista unica
    zs_prime = list(itertools.chain.from_iterable(zs_prime))
    return zs_prime

"""#### ***Predizione sulle Istanze Perturbate***"""

import tensorflow as tf

def ensemble_predict(models, images, x3_exp):
    # Se images è una lista, calcoliamo la lunghezza
    if isinstance(images, list):
        len_x3 = len(images)
    else:
        len_x3 = 1
        images = [images]  # Rendi images una lista con un solo elemento

    # Conversione in tensori
    Y_test = tf.stack([tf.convert_to_tensor(img, dtype=tf.float32) for img in images])
    Y_test_x3 = tf.tile(tf.expand_dims(tf.convert_to_tensor(x3_exp, dtype=tf.float32), axis=0), [len_x3, 1, 1])

    # Inizializza una lista per raccogliere le predizioni
    all_preds = []

    # Itera attraverso i modelli e raccogli le predizioni
    for model in models:
        preds = model.predict([Y_test, Y_test_x3], verbose=0)
        all_preds.append(preds)

    # Converte la lista di predizioni in un tensore di TensorFlow
    all_preds_tensor = tf.stack(all_preds)

    # Calcola la media lungo l'asse dei modelli (asse 0)
    mean_preds = tf.reduce_mean(all_preds_tensor, axis=0)

    return mean_preds.numpy()

"""#### ***Calcolo distanza D(x,z)***
Dove:
* D è la L2-Distance (Distanza Euclidea)
* x è l'istanza originaria da spiegare
* z è la versione perturbata non interpretabile
"""

def calculate_D(instance, perturbed_istance):
  x = instance.flatten()
  z = perturbed_istance.flatten()

  return np.linalg.norm(x - z)

"""#### ***Evaluation Metrics***"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error

def calculate_auc(x, y):
    """
    Calcola l'area sotto la curva (AUC) utilizzando il metodo del trapezio.

    :param x: Valori dell'asse x (frazione dei pixel/frame inseriti).
    :param y: Valori dell'asse y (errori calcolati).
    :return: Area sotto la curva.
    """
    return np.trapz(y, x)

def calculate_auc_and_mean_errors(errors_all_dateset):
  mean_errors = np.mean(errors_all_dateset, axis=0)
  # Array x per il numero di superpixel inseriti
  x = np.arange(0, len(mean_errors))  # Array dinamico basato sulla lunghezza dei dati
  auc = calculate_auc(x, mean_errors)

  return auc,mean_errors

"""##### ***Insertion***"""

def update_instance_with_superpixels(current_instance, original_instance, start, end, list_of_pixel):
    """
    Aggiorna l'immagine inserendo i pixel più importanti.

    :param current_instance: Istanza corrente.
    :param original_instance: Istanza originale.
    :param index_of_superpixels: Lista contente gli indici del superpixel considerato
    :return: Istanza aggiornata con il superpixel.
    """
    new_current_instance = current_instance.copy()

    for x,y in list_of_pixel:
      for t in range(start,end):
        new_current_instance[t, x, y, :] = original_instance[t, x, y, :]
    return new_current_instance

def insertion(models, original_instance, x3, sorted_per_importance_all_superpixels_index, initial_blurred_instance, original_prediction):
    """
    Calcola la metrica di inserimento per una spiegazione data.

    :param models: Lista di modelli pre-addestrati.
    :param original_instance: Istanza originale.
    :param x3: Codifica one-hot per la previsione.
    :param sorted_per_importance_all_superpixels_index: Lista di liste di tutti i superpixel per importanza
    :param initial_blurred_images: Immagine iniziale con tutti i pixel a zero.
    :return: Lista degli errori ad ogni passo di inserimento.
    """

    # Lista per memorizzare le istanze a cui aggiungo pixel mano a mano. Inizializzata con istanza iniziale blurrata
    insertion_images = [initial_blurred_instance]

    # Predizione sull'immagine iniziale (tutti i pixel a zero)
    I_prime = copy.deepcopy(initial_blurred_instance)

    # Aggiungere gradualmente i pixel (per ogni frame) più importanti. Ottengo una lista con tutte le img con i pixel aggiunti in maniera graduale
    for start,end,list_of_pixel in sorted_per_importance_all_superpixels_index:
        I_prime = update_instance_with_superpixels(I_prime, original_instance, start,end,list_of_pixel)
        insertion_images.append(I_prime)

    # Calcolo le predizioni sulle istanze a cui ho aggiunto i pixel in maniera graduale
    new_predictions = ensemble_predict(models, insertion_images, x3)
    # Rispetto ad ogni suddetta predizione, calcolo il MSE rispetto la pred sull'istanza originaria (come da test-set). Ignora la prima che è sull'img blurrata originale
    errors = [mean_squared_error(original_prediction, masked_pred) for masked_pred in new_predictions[1:]]

    initial_error = mean_squared_error(original_prediction, new_predictions[0])
    print(f"Initial Prediction with Blurred Instance, new prediction: {new_predictions[0]}, error: {initial_error}")
    only_inserted_pixel_new_predictions = new_predictions[1:]

    for nr_superpixel, error in enumerate(errors):
      print(f"SuperPixel: {sorted_per_importance_all_superpixels_index[nr_superpixel]}, new prediction: {only_inserted_pixel_new_predictions[nr_superpixel]}, error: {error}")

    total_errors = [initial_error] + errors # Errore iniziale + errori su tutti i pixel inseriti

    # Nuovo asse X: numero di superpixel inseriti (1, 2, ..., 8)
    x = np.arange(0, len(total_errors))  # Da 0 a 8 inclusi
    #print(x)

    x_for_auc = np.linspace(0, 1, len(total_errors))
    # Calcolo dell'AUC con il nuovo asse x
    auc = calculate_auc(x_for_auc, total_errors)
    print(f"Area under the curve (AUC): {auc}")

    # # Plot della curva dell'errore e area sotto la curva (AUC)
    # plt.plot(x, total_errors, marker='o', linestyle='-', label='Error curve', color='blue')
    # # Pallini blu sui punti della curva
    # plt.scatter(x, total_errors, color='blue', zorder=3)

    # # Area sotto la curva
    # plt.fill_between(x, total_errors, color='skyblue', alpha=0.4)

    # # Testo AUC in alto a destra
    # plt.text(x[-1] * 0.95, max(total_errors) * 0.9, f'AUC: {auc:.2f}',
    #      horizontalalignment='right')

    # plt.xlabel('Number of superpixels inserted')  # Modifica etichetta asse X
    # plt.ylabel('Mean Squared Error')
    # plt.title('Insertion Metric Curve')
    # #plt.xticks(x)  # Imposta i tick esattamente sui numeri interi (1, 2, ..., 8)
    # plt.legend()
    # #plt.grid(True, linestyle='--', alpha=0.6)  # Griglia più leggibile
    # plt.show()
    return total_errors,auc

"""##### ***Deletion***"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error

def update_instance_removing_superpixels(current_instance, start, end, list_of_pixel):
    """
    Aggiorna l'immagine inserendo i pixel più importanti.

    :param current_instance: Istanza corrente.
    :param original_instance: Istanza originale.
    :param index_of_superpixels: Lista contente gli indici del superpixel considerato
    :return: Istanza aggiornata con il superpixel.
    """
    new_current_instance = current_instance.copy()
    for x,y in list_of_pixel:
      for t in range(start,end):
        new_current_instance[t, x, y, :] = 0.0
    return new_current_instance

def deletion(models, original_instance, x3_instance, sorted_per_importance_all_superpixels_index, original_prediction):
    """
    Calcola la metrica di deletion per una spiegazione data.

    :param models: Lista di modelli pre-addestrati.
    :param original_instance: Istanza originale.
    :param x3_instance: Codifica one-hot per la previsione.
    :param sorted_per_importance_all_superpixels_index: Lista di liste di tutti i superpixel per importanza
    :param original_prediction: Predizione originale.
    :return: Lista degli errori ad ogni passo di deletion.
    """

    # Lista per memorizzare le istanze a cui aggiungo pixel mano a mano. Inizializzata con istanza originale
    deletion_images = []

    # Predizione sull'immagine iniziale (tutti i pixel a zero)
    I_prime = copy.deepcopy(original_instance)

    # Aggiungere gradualmente i pixel (per ogni frame) più importanti. Ottengo una lista con tutte le img con i pixel aggiunti in maniera graduale
    for start,end,list_of_pixel in sorted_per_importance_all_superpixels_index:
        I_prime = update_instance_removing_superpixels(I_prime, start, end, list_of_pixel)
        deletion_images.append(I_prime)

    # Calcolo della predizione su tutte le img a cui ho rimosso gradualmente i pixel
    new_predictions = ensemble_predict(models, deletion_images, x3_instance)
    # Calcolo del mse rispetto la predizione originale
    errors = [mean_squared_error(original_prediction, masked_pred) for masked_pred in new_predictions]

    initial_error = 0.0
    print(f"Initial Prediction with Original instance, prediction: {original_prediction}, error: {initial_error}")

    for nr_superpixel, error in enumerate(errors):
      print(f"Removed SuperPixel: {sorted_per_importance_all_superpixels_index[nr_superpixel]}, new prediction: {new_predictions[nr_superpixel]}, error: {error}")

    total_errors = [initial_error] + errors # Errore iniziale + errori su tutti i pixel rimossi

    # Plot
    # Nuovo asse X: numero di superpixel inseriti (1, 2, ..., 8)
    x = np.arange(0, len(total_errors))  # Da 0 a 8 inclusi
    #print(x)
    x_for_auc = np.linspace(0, 1, len(total_errors))
    # Calcolo dell'AUC con il nuovo asse x
    auc = calculate_auc(x_for_auc, total_errors)
    print(f"Area under the curve (AUC): {auc}")

    # # Plot della curva dell'errore e area sotto la curva (AUC)
    # plt.plot(x, total_errors, marker='o', linestyle='-', label='Error curve', color='blue')
    # # Pallini rossi sui punti della curva
    # plt.scatter(x, total_errors, color='red', zorder=3)
    # # Area sotto la curva
    # plt.fill_between(x, total_errors, color='lightcoral', alpha=0.4)

    # # Posiziona il testo AUC alla destra del titolo
    # plt.text(1.02, 1.02, f'AUC: {auc:.2f}',
    #      horizontalalignment='left',
    #      transform=plt.gca().transAxes,  # Coordinate rispetto all'asse (da 0 a 1)
    #      fontsize=11)

    # plt.xlabel('Number of superpixels removed')  # Modifica etichetta asse X
    # plt.ylabel('Mean Squared Error')
    # plt.title('Deletion Metric Curve')
    # #plt.xticks(x)  # Imposta i tick esattamente sui numeri interi (1, 2, ..., 8)
    # plt.legend()
    # #plt.grid(True, linestyle='--', alpha=0.6)  # Griglia più leggibile
    # plt.show()
    return total_errors,auc

"""### ***Experiments***"""

# def create_frame_for_saliency_video(shape, coefficients, spatial_superpixels, height=5,width=8):
#   """
#   Args:
#    - shape: (time_steps, heigth, width, nr_channels)
#    - coefficients: coefficienti spatial_superpixel per clustet temporale
#    - spatial_superpixels: matrici 5x8 per i superpixels spaziali
#   """

#   frame = np.zeros((height, width))

#   for i,superpixel in enumerate(spatial_superpixels):
#     frame += superpixel * coefficients[i]

#   return frame

# from sklearn.linear_model import Ridge
# import itertools

# def lime_st_explain(nr_instance, data_test_image, data_test_OHE, models, channel, N, kernel_width=20, alpha=10.0):

#   instance    = copy.deepcopy(data_test_image[nr_instance])
#   x3_instance = copy.deepcopy(data_test_OHE[nr_instance])

#   shape = instance.shape

#   vottignasco_test_images_dates = np.load(data_path + '/Vottignasco_00425010001_test_image_sequences_dates.npy')

#   # Converti le date in pandas datetime
#   dates = pd.to_datetime(vottignasco_test_images_dates[nr_instance])

#   # Estrai i giorni e identifica le stagioni
#   tm_days = [date.timetuple().tm_yday for date in dates]
#   seasons = [get_season(tm_yday) for tm_yday in tm_days]
#   # Temporal Superpixels
#   temporal_superpixels = cluster_seasons(seasons)

#   segments = np.array([[1, 1, 1, 1, 1, 2, 2, 3],
#        [1, 1, 1, 4, 2, 2, 3, 3],
#        [1, 1, 1, 4, 2, 2, 3, 3],
#        [5, 5, 4, 4, 6, 7, 7, 8],
#        [5, 5, 6, 6, 6, 7, 7, 8]])

#   clusters = np.unique(segments)

#   # Creazione di una lista di matrici binarie per ogni cluster
#   binary_matrices = {}
#   for cluster in clusters:
#     binary_matrices[cluster] = (segments == cluster).astype(int)

#   spatial_superpixels = [matrix for _, matrix in binary_matrices.items()]

#   spatial_superpixel_clusters = []

#   for ss in spatial_superpixels:
#     indices = np.argwhere(ss == 1)
#     cluster_pixels = [(x, y) for x, y in indices]
#     spatial_superpixel_clusters.append(cluster_pixels)


#   superpixels_positive_masks = generate_masks_uniform_noise(spatial_superpixel_clusters, temporal_superpixels, shape, +1.00)
#   negative_positive_masks = generate_masks_uniform_noise(spatial_superpixel_clusters, temporal_superpixels, shape, -1.00)

#   length = len(superpixels_positive_masks)

#   zs_primes = []

#   zs_primes.append(create_zs_each_superpixel_foreach_season(len(superpixels_positive_masks)))
#   zs_primes.append(create_zs_season(superpixels_positive_masks, spatial_superpixels))
#   zs_primes.append(create_zs_superpixel_for_contiguous_frame(superpixels_positive_masks, spatial_superpixels, temporal_superpixels))

#   zs_primes = list(itertools.chain.from_iterable(zs_primes))
#   #print(len(zs_primes))

#   # Genero N zs_primes com masks attivate con probabilità p
#   prob_activation = 0.1 # probabilità di attivare una maschera per perturbare
#   for i in range(N):
#     vec = np.random.choice([1, 0], size=length, p=[1-prob_activation, prob_activation])
#     zs_primes.append(vec)

#   zs_prime_array = np.array([vec for vec in zs_primes])
#   zs_primes = np.unique(zs_prime_array, axis=0)
#   #print(len(zs_primes))

#   # elmina zs di tutti 1 o 0
#   zs_primes = [sub_array for sub_array in zs_primes if not (all(x == 1 for x in sub_array) or all(x == 0 for x in sub_array))]
#   #print(len(zs_primes))

#    # Creazione istanze perturbate
#   perturbed_positive_instances = perturb_instance(instance, zs_primes, superpixels_positive_masks, channel)
#   perturbed_negative_instances = perturb_instance(instance, zs_primes, negative_positive_masks, channel)

#   # Predizione istanze perturbate
#   predictions_positive = ensemble_predict(models, list(perturbed_positive_instances), x3_instance)
#   predictions_negative = ensemble_predict(models, list(perturbed_negative_instances), x3_instance)

#   # Calcolo distanze
#   distances_for_positive = [calculate_D(instance, perturbed_instance) for perturbed_instance in perturbed_positive_instances]
#   distances_for_negative = [calculate_D(instance, perturbed_instance) for perturbed_instance in perturbed_negative_instances]

#   # Calcolo pi_x(z') per ogni z'

#   weights_for_positive = np.exp(- (np.array(distances_for_positive) ** 2) / (kernel_width ** 2))
#   weights_for_negative = np.exp(- (np.array(distances_for_negative) ** 2) / (kernel_width ** 2))

#   # Regressione Lineare Pesata con Ridge
#   X_for_positive = np.array([z.flatten() for z in zs_primes])  # Una riga per ogni maschera
#   y_for_positive = np.array(predictions_positive)   # Visto che siamo in regressione

#   X_for_negative = np.array([z.flatten() for z in zs_primes])  # Una riga per ogni maschera
#   y_for_negative = np.array(predictions_negative)   # Visto che siamo in regressione

#   # Crea e allena il modello con i pesi
#   regressor_for_positive = Ridge(alpha=1.0)
#   regressor_for_positive.fit(X_for_positive, y_for_positive, sample_weight=weights_for_positive)  # Pesi usati qui

#   # Coefficienti calcolati dal modello
#   coefficients_for_positive = regressor_for_positive.coef_

#   regressor_for_negative = Ridge(alpha=1.0)
#   regressor_for_negative.fit(X_for_negative, y_for_negative, sample_weight=weights_for_negative)  # Pesi usati qui

#   # Coefficienti calcolati dal modello
#   coefficients_for_negative = regressor_for_negative.coef_

#   nr_temporal_superpixel = len(temporal_superpixels)
#   nr_spatial_superpixel  = len(spatial_superpixels)
#   print(nr_temporal_superpixel, nr_spatial_superpixel)

#   coefficients_for_positive = coefficients_for_positive.reshape(nr_temporal_superpixel, nr_spatial_superpixel)
#   coefficients_for_negative = coefficients_for_negative.reshape(nr_temporal_superpixel, nr_spatial_superpixel)

#   total_coefficients = (abs(coefficients_for_positive) + abs(coefficients_for_negative))/2
#   print("Total Coefficients for Spatio-Temporal Superpixel (sum in abs/2): ", total_coefficients)

#   time_steps, height, width, nr_channels = shape

#   saliency_video_total = np.zeros((time_steps, height, width))

#   # Frame per ogni stagione individuata
#   frames_for_t_superpixels = [create_frame_for_saliency_video(shape, coeff, spatial_superpixels) for coeff in total_coefficients]

#   for i,t_superpixel in enumerate(temporal_superpixels):
#     start, end, _ = t_superpixel
#     saliency_video_total[start:end+1] = frames_for_t_superpixels[i]

#   return saliency_video_total, total_coefficients

# segments = np.array([[1, 1, 1, 1, 1, 2, 2, 3],
#        [1, 1, 1, 4, 2, 2, 3, 3],
#        [1, 1, 1, 4, 2, 2, 3, 3],
#        [5, 5, 4, 4, 6, 7, 7, 8],
#        [5, 5, 6, 6, 6, 7, 7, 8]])

# clusters = np.unique(segments)

# # Creazione di una lista di matrici binarie per ogni cluster
# binary_matrices = {}
# for cluster in clusters:
#   binary_matrices[cluster] = (segments == cluster).astype(int)

# spatial_superpixels = [matrix for _, matrix in binary_matrices.items()]

# spatial_superpixel_clusters = []

# for ss in spatial_superpixels:
#   indices = np.argwhere(ss == 1)
#   cluster_pixels = [(x, y) for x, y in indices]
#   spatial_superpixel_clusters.append(cluster_pixels)

# spatial_superpixel_clusters

# for t in range(103,104):
#   print(t)

# # Esempio

# nr_instance = 0

# vottignasco_test_images_dates = np.load(data_path + '/Vottignasco_00425010001_test_image_sequences_dates.npy')

# # Converti le date in pandas datetime
# dates = pd.to_datetime(vottignasco_test_images_dates[nr_instance])

# # Estrai i giorni e identifica le stagioni
# tm_days = [date.timetuple().tm_yday for date in dates]
# seasons = [get_season(tm_yday) for tm_yday in tm_days]

# temporal_superpixels = cluster_seasons(seasons)

# N = 1000

# models = vott_lstm_models_loaded

# nr_instance  = 0
# channel_prec = 0

# saliency_video_0, total_coefficients_0 = lime_st_explain(nr_instance, vottignasco_test_image, vottignasco_test_OHE, models, channel_prec, N)

# temporal_superpixels[7]

# spatial_superpixel_clusters[3]

# def find_top_indices(matrix):
#     # Flatten della matrice e ordinamento degli indici in base ai valori decrescenti
#     flat_indices = np.argsort(matrix.flatten())[::-1]
#     # Converti gli indici "piatti" in coordinate (x, y)
#     indices = [np.unravel_index(idx, matrix.shape) for idx in flat_indices]
#     return indices

# superpixels_importance_cluster = find_top_indices(total_coefficients_0)

# sorted_per_importance_all_superpixels_index = []

# for nr_ts, nr_ss in superpixels_importance_cluster:
#   start,end = temporal_superpixels[nr_ts][0], temporal_superpixels[nr_ts][1] + 1
#   cluster_spatial_superpixel = spatial_superpixel_clusters[nr_ss]

#   sorted_per_importance_all_superpixels_index.append((start, end, cluster_spatial_superpixel))

# for el in sorted_per_importance_all_superpixels_index:
#   print(el)

# nr_instance = 0

# instance    = copy.deepcopy(vottignasco_test_image[nr_instance])
# x3_instance = copy.deepcopy(vottignasco_test_OHE[nr_instance])    # One-Hot encode mesi dei frame dell'istanza

# all_superpixels_index = sorted_per_importance_all_superpixels_index
# initial_blurred_instance = np.zeros((instance.shape[0],instance.shape[1],instance.shape[2],instance.shape[3]))
# original_prediction = ensemble_predict(models, instance, x3_instance)

# errors,auc = insertion(models, instance, x3_instance, all_superpixels_index, initial_blurred_instance, original_prediction)

# nr_instance = 0

# instance    = copy.deepcopy(vottignasco_test_image[nr_instance])
# x3_instance = copy.deepcopy(vottignasco_test_OHE[nr_instance])    # One-Hot encode mesi dei frame dell'istanza

# all_superpixels_index = sorted_per_importance_all_superpixels_index
# original_prediction = ensemble_predict(models, instance, x3_instance)

# errors,auc = deletion(models, instance, x3_instance, all_superpixels_index, original_prediction)

"""#### ***Cineca***"""

def cluster_seasons(seasons):
    clusters = []
    start_index = 0

    for i in range(1, len(seasons)):
        if seasons[i] != seasons[i - 1]:  # Cambia stagione
            clusters.append((start_index, i - 1, seasons[start_index]))  # Salva il cluster precedente
            start_index = i  # Inizia un nuovo cluster

    # Aggiunge l'ultimo cluster
    clusters.append((start_index, len(seasons) - 1, seasons[start_index]))

    return clusters

def find_top_indices(matrix):
    # Flatten della matrice e ordinamento degli indici in base ai valori decrescenti
    flat_indices = np.argsort(matrix.flatten())[::-1]
    # Converti gli indici "piatti" in coordinate (x, y)
    indices = [np.unravel_index(idx, matrix.shape) for idx in flat_indices]
    return indices

def create_frame_for_saliency_video(shape, coefficients, spatial_superpixels, height=5,width=8):
  """
  Args:
   - shape: (time_steps, heigth, width, nr_channels)
   - coefficients: coefficienti spatial_superpixel per clustet temporale
   - spatial_superpixels: matrici 5x8 per i superpixels spaziali
  """

  frame = np.zeros((height, width))

  for i,superpixel in enumerate(spatial_superpixels):
    frame += superpixel * coefficients[i]

  return frame

from sklearn.linear_model import Ridge
import itertools

def lime_st_explain(nr_instance, data_test_image, data_test_OHE, models, channel, N, kernel_width=20, alpha=10.0):

  instance    = copy.deepcopy(data_test_image[nr_instance])
  x3_instance = copy.deepcopy(data_test_OHE[nr_instance])

  shape = instance.shape

  # Converti le date in pandas datetime
  dates = pd.to_datetime(vottignasco_test_images_dates[nr_instance])

  # Estrai i giorni e identifica le stagioni
  tm_days = [date.timetuple().tm_yday for date in dates]
  seasons = [get_season(tm_yday) for tm_yday in tm_days]
  # Temporal Superpixels
  temporal_superpixels = cluster_seasons(seasons)

  segments = np.array([[1, 1, 1, 1, 1, 2, 2, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [5, 5, 4, 4, 6, 7, 7, 8],
       [5, 5, 6, 6, 6, 7, 7, 8]])

  clusters = np.unique(segments)

  # Creazione di una lista di matrici binarie per ogni cluster
  binary_matrices = {}
  for cluster in clusters:
    binary_matrices[cluster] = (segments == cluster).astype(int)

  spatial_superpixels = [matrix for _, matrix in binary_matrices.items()]

  spatial_superpixel_clusters = []

  for ss in spatial_superpixels:
    indices = np.argwhere(ss == 1)
    cluster_pixels = [(x, y) for x, y in indices]
    spatial_superpixel_clusters.append(cluster_pixels)


  superpixels_positive_masks = generate_masks_uniform_noise(spatial_superpixel_clusters, temporal_superpixels, shape, +1.00)
  negative_positive_masks = generate_masks_uniform_noise(spatial_superpixel_clusters, temporal_superpixels, shape, -1.00)

  length = len(superpixels_positive_masks)

  zs_primes = []

  zs_primes.append(create_zs_each_superpixel_foreach_season(len(superpixels_positive_masks)))
  zs_primes.append(create_zs_season(superpixels_positive_masks, spatial_superpixels))
  zs_primes.append(create_zs_superpixel_for_contiguous_frame(superpixels_positive_masks, spatial_superpixels, temporal_superpixels))

  zs_primes = list(itertools.chain.from_iterable(zs_primes))
  #print(len(zs_primes))

  # Genero N zs_primes com masks attivate con probabilità p
  prob_activation = 0.1 # probabilità di attivare una maschera per perturbare
  for i in range(N):
    vec = np.random.choice([1, 0], size=length, p=[1-prob_activation, prob_activation])
    zs_primes.append(vec)

  zs_prime_array = np.array([vec for vec in zs_primes])
  zs_primes = np.unique(zs_prime_array, axis=0)
  #print(len(zs_primes))

  # elmina zs di tutti 1 o 0
  zs_primes = [sub_array for sub_array in zs_primes if not (all(x == 1 for x in sub_array) or all(x == 0 for x in sub_array))]
  #print(len(zs_primes))

   # Creazione istanze perturbate
  perturbed_positive_instances = perturb_instance(instance, zs_primes, superpixels_positive_masks, channel)
  perturbed_negative_instances = perturb_instance(instance, zs_primes, negative_positive_masks, channel)

  # Predizione istanze perturbate
  predictions_positive = ensemble_predict(models, list(perturbed_positive_instances), x3_instance)
  predictions_negative = ensemble_predict(models, list(perturbed_negative_instances), x3_instance)

  # Calcolo distanze
  distances_for_positive = [calculate_D(instance, perturbed_instance) for perturbed_instance in perturbed_positive_instances]
  distances_for_negative = [calculate_D(instance, perturbed_instance) for perturbed_instance in perturbed_negative_instances]

  # Calcolo pi_x(z') per ogni z'

  weights_for_positive = np.exp(- (np.array(distances_for_positive) ** 2) / (kernel_width ** 2))
  weights_for_negative = np.exp(- (np.array(distances_for_negative) ** 2) / (kernel_width ** 2))

  # Regressione Lineare Pesata con Ridge
  X_for_positive = np.array([z.flatten() for z in zs_primes])  # Una riga per ogni maschera
  y_for_positive = np.array(predictions_positive)   # Visto che siamo in regressione

  X_for_negative = np.array([z.flatten() for z in zs_primes])  # Una riga per ogni maschera
  y_for_negative = np.array(predictions_negative)   # Visto che siamo in regressione

  # Crea e allena il modello con i pesi
  regressor_for_positive = Ridge(alpha=1.0)
  regressor_for_positive.fit(X_for_positive, y_for_positive, sample_weight=weights_for_positive)  # Pesi usati qui

  # Coefficienti calcolati dal modello
  coefficients_for_positive = regressor_for_positive.coef_

  regressor_for_negative = Ridge(alpha=1.0)
  regressor_for_negative.fit(X_for_negative, y_for_negative, sample_weight=weights_for_negative)  # Pesi usati qui

  # Coefficienti calcolati dal modello
  coefficients_for_negative = regressor_for_negative.coef_

  nr_temporal_superpixel = len(temporal_superpixels)
  nr_spatial_superpixel  = len(spatial_superpixels)
  print(nr_temporal_superpixel, nr_spatial_superpixel)

  coefficients_for_positive = coefficients_for_positive.reshape(nr_temporal_superpixel, nr_spatial_superpixel)
  coefficients_for_negative = coefficients_for_negative.reshape(nr_temporal_superpixel, nr_spatial_superpixel)

  total_coefficients = (abs(coefficients_for_positive) + abs(coefficients_for_negative))/2
  print("Total Coefficients for Spatio-Temporal Superpixel (sum in abs/2): ", total_coefficients)

  time_steps, height, width, nr_channels = shape

  saliency_video_total = np.zeros((time_steps, height, width))

  # Frame per ogni stagione individuata
  frames_for_t_superpixels = [create_frame_for_saliency_video(shape, coeff, spatial_superpixels) for coeff in total_coefficients]

  for i,t_superpixel in enumerate(temporal_superpixels):
    start, end, _ = t_superpixel
    saliency_video_total[start:end+1] = frames_for_t_superpixels[i]

  return saliency_video_total, total_coefficients

channel_prec = 0      # Precipitation: canale da perturbare
channel_tmax = 1
channel_tmin = 2

shape = (104, 5, 8, 3)
T, H, W, C  = shape
models      = vott_lstm_models_loaded          # Black-boxes in ensamble da spiegare

N = 5000

kernel_width = 20
alpha = 10.0

# Superpixel trovati con slic (nr_segmenti=8, compactness=15)
segments = np.array([[1, 1, 1, 1, 1, 2, 2, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [1, 1, 1, 4, 2, 2, 3, 3],
       [5, 5, 4, 4, 6, 7, 7, 8],
       [5, 5, 6, 6, 6, 7, 7, 8]])

stats_insertion = []
stats_deletion  = []

all_insertion_stats = []
all_deletion_stats  = []
for nr_instance, _ in enumerate(vottignasco_test_image):
  print(f"############### LIME-Spatio-Temporal with N:{N}, kernel_width:{kernel_width}, alpha:{alpha}  on Instance #{nr_instance} ###############")

  # Temporal Superpixel
  # Converti le date in pandas datetime
  dates = pd.to_datetime(vottignasco_test_images_dates[nr_instance])
  # Estrai i giorni e identifica le stagioni
  tm_days = [date.timetuple().tm_yday for date in dates]
  seasons = [get_season(tm_yday) for tm_yday in tm_days]
  temporal_superpixels = cluster_seasons(seasons)

  # Spatial Superpixel
  clusters = np.unique(segments)
  # Creazione di una lista di matrici binarie per ogni cluster
  binary_matrices = {}
  for cluster in clusters:
    binary_matrices[cluster] = (segments == cluster).astype(int)

  spatial_superpixels = [matrix for _, matrix in binary_matrices.items()]
  spatial_superpixel_clusters = []

  for ss in spatial_superpixels:
    indices = np.argwhere(ss == 1)
    cluster_pixels = [(x, y) for x, y in indices]
    spatial_superpixel_clusters.append(cluster_pixels)

  saliency_video_i, total_coefficients_i = lime_st_explain(nr_instance, vottignasco_test_image, vottignasco_test_OHE, models, channel_prec, N)

  superpixels_importance_cluster = find_top_indices(total_coefficients_i)

  sorted_per_importance_all_superpixels_index = []
  for nr_ts, nr_ss in superpixels_importance_cluster:
    start,end = temporal_superpixels[nr_ts][0], temporal_superpixels[nr_ts][1] + 1
    cluster_spatial_superpixel = spatial_superpixel_clusters[nr_ss]
    sorted_per_importance_all_superpixels_index.append((start, end, cluster_spatial_superpixel))

  # Insertion
  instance    = copy.deepcopy(vottignasco_test_image[nr_instance])
  x3_instance = copy.deepcopy(vottignasco_test_OHE[nr_instance])    # One-Hot encode mesi dei frame dell'istanza

  all_superpixels_index = sorted_per_importance_all_superpixels_index
  initial_blurred_instance = np.zeros((instance.shape[0],instance.shape[1],instance.shape[2],instance.shape[3]))
  original_prediction = ensemble_predict(models, instance, x3_instance)

  errors_insertion,auc_insertion = insertion(models, instance, x3_instance, all_superpixels_index, initial_blurred_instance, original_prediction)

  #Deletion
  errors_deletion,auc_deletion = deletion(models, instance, x3_instance, all_superpixels_index, original_prediction)

  # Aggiungi la coppia [errors_insertion, auc_insertion] alla lista
  all_insertion_stats.append([errors_insertion, auc_insertion])
  # Coppia per la Deletion
  all_deletion_stats.append([errors_deletion, auc_deletion])
  print("############### END INSTANCE #{nr_instance} ###############################################################################")


only_errors_insertion = [errors for errors,_ in all_insertion_stats]
#auc_insertion,mean_errors_insertion = calculate_auc_and_mean_errors(only_errors_insertion)
stats_insertion.append(only_errors_insertion)

only_errors_deletion =  [errors for errors,_ in all_deletion_stats]
#auc_deletion,mean_errors_deletion = calculate_auc_and_mean_errors(only_errors_deletion)
stats_deletion.append(only_errors_deletion)

import pandas as pd

df_stats_mean_insertion = pd.DataFrame(stats_insertion, columns=['Insertion Errors for each SuperPixel'])
df_stats_mean_deletion  = pd.DataFrame(stats_deletion,  columns=['Deletion Errors for each SuperPixel'])

df_stats_mean_insertion.to_csv(os.path.join(work_path, f"Water_Resources/rise-video/XAI/spatial_temporal/results/additive_uniform_noise/lime_all_stats_insertion.csv"), index=False)
df_stats_mean_deletion.to_csv(os.path.join(work_path, f"Water_Resources/rise-video/XAI/spatial_temporal/results/additive_uniform_noise/lime_all_stats_deletion.csv"),   index=False)
